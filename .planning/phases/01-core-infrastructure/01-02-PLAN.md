---
phase: 01-core-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/services/auth.ts
  - src/services/email.ts
  - src/middleware/auth.ts
  - src/middleware/error-handler.ts
  - src/routes/auth/index.ts
  - src/routes/auth/register.ts
  - src/routes/auth/login.ts
  - src/routes/auth/magic-link.ts
  - src/routes/auth/refresh.ts
  - src/routes/auth/logout.ts
  - src/routes/index.ts
  - src/db/schema/magic-links.ts
  - src/db/schema/index.ts
  - src/index.ts
  - src/lib/env.ts
autonomous: true
user_setup:
  - service: resend
    why: "Magic link emails require transactional email service"
    env_vars:
      - name: RESEND_API_KEY
        source: "https://resend.com/api-keys - Create API key"
    dashboard_config:
      - task: "Verify sending domain (or use default onboarding@resend.dev for testing)"
        location: "Resend Dashboard -> Domains"

must_haves:
  truths:
    - "User can register with email and password"
    - "User can login with email and password and receive JWT"
    - "User can request magic link and receive email"
    - "User can login via magic link URL"
    - "User can refresh access token using refresh token"
    - "User can logout and refresh token is invalidated"
    - "Protected endpoints reject requests without valid JWT"
    - "Invalid credentials return 401 with RFC 7807 error"
  artifacts:
    - path: "src/services/auth.ts"
      provides: "Password hashing, JWT generation, token validation"
      exports: ["hashPassword", "verifyPassword", "generateTokens", "verifyAccessToken"]
    - path: "src/middleware/auth.ts"
      provides: "JWT validation middleware for protected routes"
      contains: "jwt"
    - path: "src/middleware/error-handler.ts"
      provides: "RFC 7807 Problem Details error responses"
      contains: "application/problem+json"
    - path: "src/routes/auth/login.ts"
      provides: "POST /api/v1/auth/login endpoint"
      contains: "Hono"
  key_links:
    - from: "src/routes/auth/login.ts"
      to: "src/services/auth.ts"
      via: "verifyPassword and generateTokens calls"
      pattern: "(verifyPassword|generateTokens)"
    - from: "src/middleware/auth.ts"
      to: "src/services/auth.ts"
      via: "verifyAccessToken call"
      pattern: "verifyAccessToken"
    - from: "src/routes/auth/magic-link.ts"
      to: "src/services/email.ts"
      via: "sendMagicLink call"
      pattern: "sendMagicLink"
---

<objective>
Implement complete authentication system with JWT tokens, password login, and magic links.

Purpose: Enable user authentication which is required for all protected API endpoints. This is the security foundation - without it, the API cannot distinguish authorized users from unauthorized requests.

Output: Working auth routes (register, login, magic-link, refresh, logout) with JWT middleware protecting future endpoints.
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-infrastructure/01-CONTEXT.md
@.planning/phases/01-core-infrastructure/01-RESEARCH.md
@.planning/phases/01-core-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth services and error handling middleware</name>
  <files>
    src/services/auth.ts
    src/services/email.ts
    src/middleware/error-handler.ts
    src/db/schema/magic-links.ts
    src/db/schema/index.ts
    src/lib/env.ts
  </files>
  <action>
Create core authentication services and RFC 7807 error handling:

**Update src/lib/env.ts** - Add APP_URL for magic link generation:
```typescript
// Add to envSchema:
APP_URL: z.string().url().default('http://localhost:3000'),
```

**Create src/db/schema/magic-links.ts**:
```typescript
import { pgTable, uuid, varchar, timestamp, boolean } from 'drizzle-orm/pg-core';
import { users } from './users';

export const magicLinks = pgTable('magic_links', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  token: varchar('token', { length: 255 }).notNull().unique(),
  expiresAt: timestamp('expires_at', { withTimezone: true }).notNull(),
  usedAt: timestamp('used_at', { withTimezone: true }),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
});
```

**Update src/db/schema/index.ts** to export magic-links:
```typescript
export * from './magic-links';
```

Run migration after creating schema:
```bash
bun run db:generate && bun run db:migrate
```

**Create src/services/auth.ts**:
```typescript
import { sign, verify } from 'hono/jwt';
import { hash, verify as verifyHash } from '@node-rs/argon2';
import { env } from '../lib/env';
import { db, schema } from '../db';
import { eq, and, gt } from 'drizzle-orm';
import { randomBytes } from 'crypto';

const ARGON2_OPTIONS = {
  memoryCost: 65536,    // 64 MB
  timeCost: 3,
  parallelism: 4,
};

const ACCESS_TOKEN_EXPIRY = 15 * 60;        // 15 minutes
const REFRESH_TOKEN_EXPIRY = 7 * 24 * 60 * 60; // 7 days

export interface TokenPayload {
  sub: string;        // user ID
  org: string;        // organization ID
  email: string;
  iat: number;
  exp: number;
}

export interface RefreshPayload {
  sub: string;
  jti: string;        // token ID for revocation
  iat: number;
  exp: number;
}

export async function hashPassword(password: string): Promise<string> {
  return hash(password, ARGON2_OPTIONS);
}

export async function verifyPassword(storedHash: string, password: string): Promise<boolean> {
  try {
    return await verifyHash(storedHash, password);
  } catch {
    return false;
  }
}

export async function generateTokens(user: { id: string; orgId: string; email: string }) {
  const now = Math.floor(Date.now() / 1000);
  const jti = randomBytes(16).toString('hex');

  const accessToken = await sign(
    {
      sub: user.id,
      org: user.orgId,
      email: user.email,
      iat: now,
      exp: now + ACCESS_TOKEN_EXPIRY,
    } satisfies TokenPayload,
    env.JWT_SECRET
  );

  const refreshToken = await sign(
    {
      sub: user.id,
      jti,
      iat: now,
      exp: now + REFRESH_TOKEN_EXPIRY,
    } satisfies RefreshPayload,
    env.JWT_REFRESH_SECRET
  );

  // Store refresh token hash in database
  const tokenHash = await hash(refreshToken, ARGON2_OPTIONS);
  await db.insert(schema.refreshTokens).values({
    userId: user.id,
    tokenHash,
    expiresAt: new Date((now + REFRESH_TOKEN_EXPIRY) * 1000),
  });

  return { accessToken, refreshToken };
}

export async function verifyAccessToken(token: string): Promise<TokenPayload | null> {
  try {
    const payload = await verify(token, env.JWT_SECRET) as TokenPayload;
    return payload;
  } catch {
    return null;
  }
}

export async function verifyRefreshToken(token: string): Promise<{ userId: string } | null> {
  try {
    const payload = await verify(token, env.JWT_REFRESH_SECRET) as RefreshPayload;

    // Find matching refresh token in database
    const storedTokens = await db.query.refreshTokens.findMany({
      where: and(
        eq(schema.refreshTokens.userId, payload.sub),
        gt(schema.refreshTokens.expiresAt, new Date())
      ),
    });

    // Verify one of the stored tokens matches
    for (const stored of storedTokens) {
      if (await verifyHash(stored.tokenHash, token)) {
        // Delete the used token (rotation)
        await db.delete(schema.refreshTokens).where(eq(schema.refreshTokens.id, stored.id));
        return { userId: payload.sub };
      }
    }

    return null;
  } catch {
    return null;
  }
}

export async function revokeAllRefreshTokens(userId: string): Promise<void> {
  await db.delete(schema.refreshTokens).where(eq(schema.refreshTokens.userId, userId));
}

export function generateMagicLinkToken(): string {
  return randomBytes(32).toString('hex');
}
```

**Create src/services/email.ts**:
```typescript
import { Resend } from 'resend';
import { env } from '../lib/env';
import { logger } from '../lib/logger';

const resend = new Resend(env.RESEND_API_KEY);

export async function sendMagicLink(email: string, token: string): Promise<boolean> {
  const magicLinkUrl = `${env.APP_URL}/api/v1/auth/magic-link/verify?token=${token}`;

  try {
    const { error } = await resend.emails.send({
      from: 'BlockBot <noreply@resend.dev>', // Use verified domain in production
      to: email,
      subject: 'Sign in to BlockBot',
      html: `
        <h1>Sign in to BlockBot</h1>
        <p>Click the link below to sign in. This link expires in 15 minutes.</p>
        <a href="${magicLinkUrl}">Sign in to BlockBot</a>
        <p>If you didn't request this, you can safely ignore this email.</p>
      `,
    });

    if (error) {
      logger.error({ error, email }, 'Failed to send magic link email');
      return false;
    }

    logger.info({ email }, 'Magic link email sent');
    return true;
  } catch (err) {
    logger.error({ err, email }, 'Exception sending magic link email');
    return false;
  }
}
```

**Create src/middleware/error-handler.ts**:
```typescript
import { Context, Next } from 'hono';
import { HTTPException } from 'hono/http-exception';
import { logger } from '../lib/logger';

export interface ProblemDetails {
  type: string;
  title: string;
  status: number;
  detail?: string;
  instance?: string;
}

export class ApiError extends Error {
  constructor(
    public status: number,
    public type: string,
    public title: string,
    public detail?: string
  ) {
    super(title);
    this.name = 'ApiError';
  }

  toProblemDetails(instance?: string): ProblemDetails {
    return {
      type: `https://blockbot.dev/errors/${this.type}`,
      title: this.title,
      status: this.status,
      detail: this.detail,
      instance,
    };
  }
}

export async function errorHandler(c: Context, next: Next) {
  try {
    await next();
  } catch (err) {
    const instance = c.req.path;

    if (err instanceof ApiError) {
      logger.warn({ err, path: instance }, 'API error');
      return c.json(err.toProblemDetails(instance), {
        status: err.status,
        headers: { 'Content-Type': 'application/problem+json' },
      });
    }

    if (err instanceof HTTPException) {
      const problem: ProblemDetails = {
        type: 'https://blockbot.dev/errors/http-exception',
        title: err.message || 'HTTP Exception',
        status: err.status,
        instance,
      };
      return c.json(problem, {
        status: err.status,
        headers: { 'Content-Type': 'application/problem+json' },
      });
    }

    // Unexpected error
    logger.error({ err, path: instance }, 'Unexpected error');
    const problem: ProblemDetails = {
      type: 'https://blockbot.dev/errors/internal',
      title: 'Internal Server Error',
      status: 500,
      instance,
    };
    return c.json(problem, {
      status: 500,
      headers: { 'Content-Type': 'application/problem+json' },
    });
  }
}
```
  </action>
  <verify>
    Files exist: `ls src/services/auth.ts src/services/email.ts src/middleware/error-handler.ts`
    Schema updated: `ls src/db/schema/magic-links.ts`
    Migration applied: `bun run db:migrate` completes successfully
    TypeScript compiles: `bun run --bun tsc --noEmit`
  </verify>
  <done>
    Auth services created with password hashing, JWT generation, token verification, and RFC 7807 error handling
  </done>
</task>

<task type="auto">
  <name>Task 2: Create auth routes and middleware</name>
  <files>
    src/middleware/auth.ts
    src/routes/auth/index.ts
    src/routes/auth/register.ts
    src/routes/auth/login.ts
    src/routes/auth/magic-link.ts
    src/routes/auth/refresh.ts
    src/routes/auth/logout.ts
    src/routes/index.ts
    src/index.ts
  </files>
  <action>
Create authentication routes and JWT middleware:

**Create src/middleware/auth.ts**:
```typescript
import { Context, Next } from 'hono';
import { verifyAccessToken, TokenPayload } from '../services/auth';
import { ApiError } from './error-handler';

declare module 'hono' {
  interface ContextVariableMap {
    user: TokenPayload;
  }
}

export async function authMiddleware(c: Context, next: Next) {
  const authHeader = c.req.header('Authorization');

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    throw new ApiError(401, 'auth/missing-token', 'Missing Authentication Token', 'Authorization header with Bearer token is required');
  }

  const token = authHeader.slice(7);
  const payload = await verifyAccessToken(token);

  if (!payload) {
    throw new ApiError(401, 'auth/invalid-token', 'Invalid Authentication Token', 'The provided access token is invalid or expired');
  }

  c.set('user', payload);
  await next();
}
```

**Create src/routes/auth/register.ts**:
```typescript
import { Hono } from 'hono';
import { z } from 'zod';
import { zValidator } from '@hono/zod-validator';
import { db, schema } from '../../db';
import { eq } from 'drizzle-orm';
import { hashPassword, generateTokens } from '../../services/auth';
import { ApiError } from '../../middleware/error-handler';

const app = new Hono();

const registerSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8, 'Password must be at least 8 characters'),
  orgName: z.string().min(1).max(255),
});

app.post('/', zValidator('json', registerSchema), async (c) => {
  const { email, password, orgName } = c.req.valid('json');

  // Check if email already exists
  const existingUser = await db.query.users.findFirst({
    where: eq(schema.users.email, email),
  });

  if (existingUser) {
    throw new ApiError(409, 'auth/email-exists', 'Email Already Registered', 'An account with this email already exists');
  }

  // Create organization and user in transaction
  const passwordHash = await hashPassword(password);

  const [org] = await db.insert(schema.organizations).values({ name: orgName }).returning();

  const [user] = await db.insert(schema.users).values({
    orgId: org.id,
    email,
    passwordHash,
    emailVerified: false,
  }).returning();

  const tokens = await generateTokens({ id: user.id, orgId: org.id, email: user.email });

  return c.json({
    user: { id: user.id, email: user.email, orgId: org.id },
    accessToken: tokens.accessToken,
    refreshToken: tokens.refreshToken,
  }, 201);
});

export default app;
```

Note: Add `bun add @hono/zod-validator` for request validation.

**Create src/routes/auth/login.ts**:
```typescript
import { Hono } from 'hono';
import { z } from 'zod';
import { zValidator } from '@hono/zod-validator';
import { db, schema } from '../../db';
import { eq } from 'drizzle-orm';
import { verifyPassword, generateTokens } from '../../services/auth';
import { ApiError } from '../../middleware/error-handler';

const app = new Hono();

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string(),
});

app.post('/', zValidator('json', loginSchema), async (c) => {
  const { email, password } = c.req.valid('json');

  const user = await db.query.users.findFirst({
    where: eq(schema.users.email, email),
  });

  if (!user || !user.passwordHash) {
    throw new ApiError(401, 'auth/invalid-credentials', 'Invalid Credentials', 'Email or password is incorrect');
  }

  const valid = await verifyPassword(user.passwordHash, password);
  if (!valid) {
    throw new ApiError(401, 'auth/invalid-credentials', 'Invalid Credentials', 'Email or password is incorrect');
  }

  const tokens = await generateTokens({ id: user.id, orgId: user.orgId, email: user.email });

  return c.json({
    user: { id: user.id, email: user.email, orgId: user.orgId },
    accessToken: tokens.accessToken,
    refreshToken: tokens.refreshToken,
  });
});

export default app;
```

**Create src/routes/auth/magic-link.ts**:
```typescript
import { Hono } from 'hono';
import { z } from 'zod';
import { zValidator } from '@hono/zod-validator';
import { db, schema } from '../../db';
import { eq, and, gt, isNull } from 'drizzle-orm';
import { generateMagicLinkToken, generateTokens } from '../../services/auth';
import { sendMagicLink } from '../../services/email';
import { ApiError } from '../../middleware/error-handler';

const app = new Hono();

const requestSchema = z.object({
  email: z.string().email(),
});

// Request magic link
app.post('/request', zValidator('json', requestSchema), async (c) => {
  const { email } = c.req.valid('json');

  const user = await db.query.users.findFirst({
    where: eq(schema.users.email, email),
  });

  // Always return success to prevent email enumeration
  if (!user) {
    return c.json({ message: 'If an account exists, a magic link has been sent' });
  }

  const token = generateMagicLinkToken();
  const expiresAt = new Date(Date.now() + 15 * 60 * 1000); // 15 minutes

  await db.insert(schema.magicLinks).values({
    userId: user.id,
    token,
    expiresAt,
  });

  await sendMagicLink(email, token);

  return c.json({ message: 'If an account exists, a magic link has been sent' });
});

// Verify magic link
app.get('/verify', async (c) => {
  const token = c.req.query('token');

  if (!token) {
    throw new ApiError(400, 'auth/missing-token', 'Missing Token', 'Magic link token is required');
  }

  const magicLink = await db.query.magicLinks.findFirst({
    where: and(
      eq(schema.magicLinks.token, token),
      gt(schema.magicLinks.expiresAt, new Date()),
      isNull(schema.magicLinks.usedAt)
    ),
  });

  if (!magicLink) {
    throw new ApiError(401, 'auth/invalid-magic-link', 'Invalid Magic Link', 'This magic link is invalid or has expired');
  }

  // Mark as used
  await db.update(schema.magicLinks)
    .set({ usedAt: new Date() })
    .where(eq(schema.magicLinks.id, magicLink.id));

  // Mark email as verified
  await db.update(schema.users)
    .set({ emailVerified: true })
    .where(eq(schema.users.id, magicLink.userId));

  const user = await db.query.users.findFirst({
    where: eq(schema.users.id, magicLink.userId),
  });

  if (!user) {
    throw new ApiError(500, 'auth/user-not-found', 'User Not Found', 'User associated with magic link not found');
  }

  const tokens = await generateTokens({ id: user.id, orgId: user.orgId, email: user.email });

  return c.json({
    user: { id: user.id, email: user.email, orgId: user.orgId },
    accessToken: tokens.accessToken,
    refreshToken: tokens.refreshToken,
  });
});

export default app;
```

**Create src/routes/auth/refresh.ts**:
```typescript
import { Hono } from 'hono';
import { z } from 'zod';
import { zValidator } from '@hono/zod-validator';
import { db, schema } from '../../db';
import { eq } from 'drizzle-orm';
import { verifyRefreshToken, generateTokens } from '../../services/auth';
import { ApiError } from '../../middleware/error-handler';

const app = new Hono();

const refreshSchema = z.object({
  refreshToken: z.string(),
});

app.post('/', zValidator('json', refreshSchema), async (c) => {
  const { refreshToken } = c.req.valid('json');

  const result = await verifyRefreshToken(refreshToken);
  if (!result) {
    throw new ApiError(401, 'auth/invalid-refresh-token', 'Invalid Refresh Token', 'The refresh token is invalid or has been revoked');
  }

  const user = await db.query.users.findFirst({
    where: eq(schema.users.id, result.userId),
  });

  if (!user) {
    throw new ApiError(401, 'auth/user-not-found', 'User Not Found', 'User associated with token not found');
  }

  const tokens = await generateTokens({ id: user.id, orgId: user.orgId, email: user.email });

  return c.json({
    accessToken: tokens.accessToken,
    refreshToken: tokens.refreshToken,
  });
});

export default app;
```

**Create src/routes/auth/logout.ts**:
```typescript
import { Hono } from 'hono';
import { revokeAllRefreshTokens } from '../../services/auth';
import { authMiddleware } from '../../middleware/auth';

const app = new Hono();

app.post('/', authMiddleware, async (c) => {
  const user = c.get('user');
  await revokeAllRefreshTokens(user.sub);
  return c.json({ message: 'Logged out successfully' });
});

export default app;
```

**Create src/routes/auth/index.ts**:
```typescript
import { Hono } from 'hono';
import register from './register';
import login from './login';
import magicLink from './magic-link';
import refresh from './refresh';
import logout from './logout';

const app = new Hono();

app.route('/register', register);
app.route('/login', login);
app.route('/magic-link', magicLink);
app.route('/refresh', refresh);
app.route('/logout', logout);

export default app;
```

**Create src/routes/index.ts**:
```typescript
import { Hono } from 'hono';
import auth from './auth';

const app = new Hono();

app.route('/auth', auth);

export default app;
```

**Update src/index.ts** to use routes and middleware:
```typescript
import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { env } from './lib/env';
import { logger } from './lib/logger';
import { connectRedis } from './lib/redis';
import { errorHandler } from './middleware/error-handler';
import routes from './routes';

const app = new Hono();

// Global middleware
app.use('*', cors({ origin: env.CORS_ORIGIN, credentials: true }));
app.use('*', errorHandler);

// Health check (unprotected)
app.get('/health', async (c) => {
  return c.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// API routes
app.route('/api/v1', routes);

// Start server
async function main() {
  await connectRedis();
  logger.info({ port: env.PORT }, 'Starting BlockBot API');

  Bun.serve({
    port: env.PORT,
    fetch: app.fetch,
  });

  logger.info({ port: env.PORT }, 'BlockBot API started');
}

main().catch((err) => {
  logger.fatal({ err }, 'Failed to start server');
  process.exit(1);
});
```

Install additional dependency:
```bash
bun add @hono/zod-validator
```
  </action>
  <verify>
Test the complete auth flow:

1. Register:
```bash
curl -X POST http://localhost:3000/api/v1/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"password123","orgName":"Test Org"}'
```
Should return 201 with user, accessToken, refreshToken

2. Login:
```bash
curl -X POST http://localhost:3000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"password123"}'
```
Should return 200 with tokens

3. Invalid login:
```bash
curl -X POST http://localhost:3000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"wrongpassword"}'
```
Should return 401 with RFC 7807 error

4. Refresh:
```bash
curl -X POST http://localhost:3000/api/v1/auth/refresh \
  -H "Content-Type: application/json" \
  -d '{"refreshToken":"<token_from_login>"}'
```
Should return new tokens

5. Logout (with auth):
```bash
curl -X POST http://localhost:3000/api/v1/auth/logout \
  -H "Authorization: Bearer <access_token>"
```
Should return 200
  </verify>
  <done>
    All auth endpoints working: register returns 201, login returns tokens, invalid credentials return 401, refresh rotates tokens, logout invalidates all refresh tokens
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Register new user: POST /api/v1/auth/register returns 201 with tokens
2. Login with password: POST /api/v1/auth/login returns 200 with tokens
3. Invalid credentials: Returns 401 with Content-Type: application/problem+json
4. Request magic link: POST /api/v1/auth/magic-link/request returns 200
5. Verify magic link: GET /api/v1/auth/magic-link/verify?token=xxx returns tokens
6. Refresh tokens: POST /api/v1/auth/refresh returns new token pair
7. Logout: POST /api/v1/auth/logout (with Bearer token) returns 200
8. Protected route without token: Returns 401
</verification>

<success_criteria>
- User can register with email, password, and org name
- User can login with email and password
- User can request and use magic link for passwordless login
- JWT access tokens are short-lived (15 min)
- Refresh tokens are long-lived (7 days) and rotate on use
- Logout revokes all refresh tokens for user
- All errors return RFC 7807 Problem Details format
- Auth middleware rejects invalid/missing tokens with 401
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-infrastructure/01-02-SUMMARY.md`
</output>
