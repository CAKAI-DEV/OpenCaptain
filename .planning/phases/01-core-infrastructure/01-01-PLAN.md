---
phase: 01-core-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - bunfig.toml
  - drizzle.config.ts
  - src/lib/env.ts
  - src/lib/logger.ts
  - src/lib/redis.ts
  - src/db/index.ts
  - src/db/schema/index.ts
  - src/db/schema/organizations.ts
  - src/db/schema/users.ts
  - src/db/schema/refresh-tokens.ts
  - src/index.ts
  - docker-compose.yml
  - .env.example
autonomous: true

must_haves:
  truths:
    - "PostgreSQL container starts and accepts connections"
    - "Redis container starts and accepts connections"
    - "Drizzle migrations run successfully against PostgreSQL"
    - "Environment variables are validated at startup"
    - "Application starts without errors when all env vars are set"
  artifacts:
    - path: "src/db/schema/organizations.ts"
      provides: "Organization model with id, name, createdAt"
      contains: "pgTable"
    - path: "src/db/schema/users.ts"
      provides: "User model with org_id, email, passwordHash, emailVerified"
      contains: "pgTable"
    - path: "src/lib/env.ts"
      provides: "Validated environment configuration"
      contains: "envSchema"
    - path: "docker-compose.yml"
      provides: "PostgreSQL and Redis services with health checks"
      contains: "healthcheck"
  key_links:
    - from: "src/db/index.ts"
      to: "src/lib/env.ts"
      via: "DATABASE_URL from validated env"
      pattern: "env\\.DATABASE_URL"
    - from: "src/lib/redis.ts"
      to: "src/lib/env.ts"
      via: "REDIS_URL from validated env"
      pattern: "env\\.REDIS_URL"
---

<objective>
Set up project foundation with database, cache, and core schemas for BlockBot.

Purpose: Establish the data layer and development environment that all subsequent features build upon. Without this foundation, authentication and API gateway cannot be implemented.

Output: Working Bun project with PostgreSQL + Redis running in Docker, Drizzle ORM configured with base schemas (organizations, users, refresh_tokens), and environment validation.
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-infrastructure/01-CONTEXT.md
@.planning/phases/01-core-infrastructure/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Bun project with dependencies</name>
  <files>
    package.json
    tsconfig.json
    bunfig.toml
    .env.example
  </files>
  <action>
Initialize a new Bun project in the repository root:

1. Run `bun init` to create package.json (accept defaults, entry point: src/index.ts)

2. Install dependencies:
   ```bash
   bun add hono @hono/node-server drizzle-orm postgres zod pino resend @node-rs/argon2
   bun add -d drizzle-kit @types/bun typescript
   ```

3. Create tsconfig.json with strict mode:
   ```json
   {
     "compilerOptions": {
       "target": "ESNext",
       "module": "ESNext",
       "moduleResolution": "bundler",
       "strict": true,
       "esModuleInterop": true,
       "skipLibCheck": true,
       "outDir": "./dist",
       "rootDir": "./src",
       "types": ["bun-types"]
     },
     "include": ["src/**/*"],
     "exclude": ["node_modules"]
   }
   ```

4. Create bunfig.toml:
   ```toml
   [run]
   preload = ["./src/lib/env.ts"]
   ```

5. Create .env.example with all required variables (use placeholder values):
   - DATABASE_URL=postgres://blockbot:password@localhost:5432/blockbot
   - REDIS_URL=redis://localhost:6379
   - JWT_SECRET=your-32-character-secret-key-here
   - JWT_REFRESH_SECRET=another-32-character-secret-here
   - RESEND_API_KEY=re_placeholder_key
   - NODE_ENV=development
   - PORT=3000
   - CORS_ORIGIN=http://localhost:3000

6. Add scripts to package.json:
   ```json
   "scripts": {
     "dev": "bun run --hot src/index.ts",
     "start": "bun run src/index.ts",
     "db:generate": "drizzle-kit generate",
     "db:migrate": "drizzle-kit migrate",
     "db:studio": "drizzle-kit studio"
   }
   ```
  </action>
  <verify>
    `bun run --help` shows available scripts
    `ls package.json tsconfig.json bunfig.toml .env.example` shows all files exist
  </verify>
  <done>
    Project initialized with all dependencies installed, TypeScript configured, and environment template created
  </done>
</task>

<task type="auto">
  <name>Task 2: Set up Docker Compose with PostgreSQL and Redis</name>
  <files>
    docker-compose.yml
  </files>
  <action>
Create docker-compose.yml with PostgreSQL 16 and Redis 7, both with health checks:

```yaml
services:
  postgres:
    image: postgres:16-alpine
    container_name: blockbot-postgres
    environment:
      POSTGRES_DB: blockbot
      POSTGRES_USER: blockbot
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-devpassword}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U blockbot -d blockbot"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  redis:
    image: redis:7-alpine
    container_name: blockbot-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
  redis_data:
```

Key details:
- Use Alpine images for smaller size
- PostgreSQL health check uses pg_isready (not just tcp check)
- Redis health check uses redis-cli ping
- Volumes persist data between restarts
- Default password for dev; prod uses env var

After creating the file, start the services:
```bash
docker compose up -d postgres redis
```

Wait for health checks to pass:
```bash
docker compose ps
```
Both should show "healthy" status.
  </action>
  <verify>
    `docker compose ps` shows postgres and redis as "healthy"
    `docker exec blockbot-postgres pg_isready -U blockbot` returns "accepting connections"
    `docker exec blockbot-redis redis-cli ping` returns "PONG"
  </verify>
  <done>
    PostgreSQL and Redis running in Docker with health checks passing
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Drizzle schemas and core libraries</name>
  <files>
    drizzle.config.ts
    src/lib/env.ts
    src/lib/logger.ts
    src/lib/redis.ts
    src/db/index.ts
    src/db/schema/index.ts
    src/db/schema/organizations.ts
    src/db/schema/users.ts
    src/db/schema/refresh-tokens.ts
    src/index.ts
  </files>
  <action>
Create the following files:

**src/lib/env.ts** - Environment validation with Zod:
```typescript
import { z } from 'zod';

const envSchema = z.object({
  DATABASE_URL: z.string().url(),
  REDIS_URL: z.string().url(),
  JWT_SECRET: z.string().min(32, 'JWT_SECRET must be at least 32 characters'),
  JWT_REFRESH_SECRET: z.string().min(32, 'JWT_REFRESH_SECRET must be at least 32 characters'),
  RESEND_API_KEY: z.string().startsWith('re_'),
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  PORT: z.coerce.number().default(3000),
  CORS_ORIGIN: z.string().url().default('http://localhost:3000'),
});

export const env = envSchema.parse(Bun.env);
export type Env = z.infer<typeof envSchema>;
```

**src/lib/logger.ts** - Pino structured logging:
```typescript
import pino from 'pino';
import { env } from './env';

export const logger = pino({
  level: env.NODE_ENV === 'production' ? 'info' : 'debug',
  formatters: {
    level: (label) => ({ level: label }),
  },
  timestamp: pino.stdTimeFunctions.isoTime,
});
```

**src/lib/redis.ts** - Redis connection (using Bun's native Redis support or ioredis):
```typescript
import { createClient } from 'redis';
import { env } from './env';
import { logger } from './logger';

export const redis = createClient({ url: env.REDIS_URL });

redis.on('error', (err) => logger.error({ err }, 'Redis connection error'));
redis.on('connect', () => logger.info('Redis connected'));

export async function connectRedis() {
  if (!redis.isOpen) {
    await redis.connect();
  }
  return redis;
}
```

Note: Add `bun add redis` for the redis client.

**src/db/schema/organizations.ts**:
```typescript
import { pgTable, uuid, varchar, timestamp } from 'drizzle-orm/pg-core';

export const organizations = pgTable('organizations', {
  id: uuid('id').primaryKey().defaultRandom(),
  name: varchar('name', { length: 255 }).notNull(),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
});
```

**src/db/schema/users.ts**:
```typescript
import { pgTable, uuid, varchar, timestamp, boolean } from 'drizzle-orm/pg-core';
import { organizations } from './organizations';

export const users = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  orgId: uuid('org_id').notNull().references(() => organizations.id, { onDelete: 'cascade' }),
  email: varchar('email', { length: 255 }).notNull().unique(),
  passwordHash: varchar('password_hash', { length: 255 }),
  emailVerified: boolean('email_verified').default(false).notNull(),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
});
```

**src/db/schema/refresh-tokens.ts**:
```typescript
import { pgTable, uuid, varchar, timestamp } from 'drizzle-orm/pg-core';
import { users } from './users';

export const refreshTokens = pgTable('refresh_tokens', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  tokenHash: varchar('token_hash', { length: 255 }).notNull(),
  expiresAt: timestamp('expires_at', { withTimezone: true }).notNull(),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
});
```

**src/db/schema/index.ts**:
```typescript
export * from './organizations';
export * from './users';
export * from './refresh-tokens';
```

**src/db/index.ts**:
```typescript
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import { env } from '../lib/env';
import * as schema from './schema';

const client = postgres(env.DATABASE_URL);
export const db = drizzle(client, { schema });
export { schema };
```

**drizzle.config.ts**:
```typescript
import type { Config } from 'drizzle-kit';

export default {
  schema: './src/db/schema/index.ts',
  out: './src/db/migrations',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
} satisfies Config;
```

**src/index.ts** - Minimal Hono app to verify everything works:
```typescript
import { Hono } from 'hono';
import { env } from './lib/env';
import { logger } from './lib/logger';
import { connectRedis } from './lib/redis';
import { db } from './db';

const app = new Hono();

app.get('/health', async (c) => {
  return c.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// Start server
async function main() {
  await connectRedis();
  logger.info({ port: env.PORT }, 'Starting BlockBot API');

  Bun.serve({
    port: env.PORT,
    fetch: app.fetch,
  });

  logger.info({ port: env.PORT }, 'BlockBot API started');
}

main().catch((err) => {
  logger.fatal({ err }, 'Failed to start server');
  process.exit(1);
});
```

After creating all files:
1. Copy .env.example to .env and fill in real values
2. Generate and run migrations:
   ```bash
   bun run db:generate
   bun run db:migrate
   ```
3. Start the dev server:
   ```bash
   bun run dev
   ```
  </action>
  <verify>
    `bun run db:generate` creates migration files in src/db/migrations/
    `bun run db:migrate` applies migrations without errors
    `bun run dev` starts server
    `curl http://localhost:3000/health` returns {"status":"ok",...}
  </verify>
  <done>
    Drizzle schemas created, migrations applied, and application starts successfully with /health endpoint responding
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `docker compose ps` shows postgres and redis healthy
2. `curl http://localhost:3000/health` returns 200 with JSON body
3. Database has organizations, users, and refresh_tokens tables
4. Application logs show structured JSON output
</verification>

<success_criteria>
- PostgreSQL 16 running in Docker with health checks
- Redis 7 running in Docker with health checks
- Drizzle ORM configured with organizations, users, refresh_tokens schemas
- Migrations applied successfully
- Environment variables validated at startup via Zod
- Hono app starts and responds to /health
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-infrastructure/01-01-SUMMARY.md`
</output>
