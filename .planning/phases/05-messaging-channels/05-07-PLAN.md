---
phase: 05-messaging-channels
plan: 07
type: execute
wave: 4
depends_on: ["05-05", "05-06"]
files_modified:
  - src/features/messaging/messaging.proactive.ts
  - src/features/messaging/messaging.worker.ts
  - src/features/notifications/activity-feed.service.ts
  - src/features/notifications/notifications.routes.ts
  - src/shared/lib/queue/client.ts
autonomous: true

must_haves:
  truths:
    - "Agent sends daily check-in messages to users who opted in"
    - "Agent sends alerts for overdue tasks"
    - "Agent sends weekly recap summaries"
    - "User can view activity feed for their project"
    - "Proactive messages respect user preferences"
  artifacts:
    - path: "src/features/messaging/messaging.worker.ts"
      provides: "BullMQ worker for proactive messaging"
      contains: "proactiveMessagingWorker"
    - path: "src/features/messaging/messaging.proactive.ts"
      provides: "Proactive message content generation"
      exports: ["generateDailyCheckin", "generateOverdueAlert", "generateWeeklyRecap"]
    - path: "src/features/notifications/activity-feed.service.ts"
      provides: "Activity feed query"
      exports: ["getActivityFeed"]
  key_links:
    - from: "src/features/messaging/messaging.worker.ts"
      to: "proactiveMessagingQueue"
      via: "BullMQ repeatable jobs"
      pattern: "repeat.*pattern"
    - from: "src/features/messaging/messaging.worker.ts"
      to: "sendTelegramMessage from ../telegram"
      via: "messaging delivery"
      pattern: "import.*sendTelegramMessage.*from.*telegram"
    - from: "src/features/messaging/messaging.proactive.ts"
      to: "tasks service"
      via: "query for tasks due/overdue"
      pattern: "getUpcomingTasks|getOverdueTasks"
---

<objective>
Implement proactive messaging (check-ins, alerts, recaps) and activity feed.

Purpose: Enable agent to proactively reach out with useful information (MSG-06) and provide activity feed (COMM-04).
Output: Proactive messaging worker, content generators, and activity feed API.
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-messaging-channels/05-RESEARCH.md

@src/shared/lib/queue/client.ts
@src/shared/lib/queue/workers.ts
@src/shared/db/schema/user-messaging.ts
@src/shared/db/schema/notifications.ts
@src/features/tasks/tasks.service.ts
@src/features/metrics/metrics.service.ts
@src/features/telegram/index.ts
@src/features/whatsapp/whatsapp.client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create proactive message content generators</name>
  <files>src/features/messaging/messaging.proactive.ts</files>
  <action>
Create messaging.proactive.ts following RESEARCH.md Pattern 6:

```typescript
import { db, schema } from '../../shared/db';
import { eq, and, lt, isNull, or, gte, lte, desc, sql } from 'drizzle-orm';
import { logger } from '../../shared/lib/logger';

export interface TaskSummary {
  id: string;
  title: string;
  dueDate: Date | null;
  priority: string | null;
  status: string | null;
}

/**
 * Get tasks due today for a user
 */
export async function getUpcomingTasks(
  userId: string,
  projectId: string | null,
  range: 'today' | 'this_week' = 'today'
): Promise<TaskSummary[]> {
  const now = new Date();
  let endDate: Date;

  if (range === 'today') {
    endDate = new Date(now);
    endDate.setHours(23, 59, 59, 999);
  } else {
    endDate = new Date(now);
    endDate.setDate(endDate.getDate() + 7);
  }

  const startDate = new Date(now);
  startDate.setHours(0, 0, 0, 0);

  const conditions: any[] = [
    eq(schema.tasks.assigneeId, userId),
    gte(schema.tasks.dueDate, startDate),
    lte(schema.tasks.dueDate, endDate),
    or(
      eq(schema.tasks.status, 'todo'),
      eq(schema.tasks.status, 'in_progress')
    ),
  ];

  if (projectId) {
    conditions.push(eq(schema.tasks.projectId, projectId));
  }

  const tasks = await db.query.tasks.findMany({
    where: and(...conditions),
    columns: { id: true, title: true, dueDate: true, priority: true, status: true },
    orderBy: (tasks, { asc }) => [asc(tasks.dueDate)],
    limit: 10,
  });

  return tasks;
}

/**
 * Get overdue tasks for a user
 */
export async function getOverdueTasks(
  userId: string,
  projectId: string | null
): Promise<TaskSummary[]> {
  const now = new Date();
  now.setHours(0, 0, 0, 0);

  const conditions: any[] = [
    eq(schema.tasks.assigneeId, userId),
    lt(schema.tasks.dueDate, now),
    or(
      eq(schema.tasks.status, 'todo'),
      eq(schema.tasks.status, 'in_progress')
    ),
  ];

  if (projectId) {
    conditions.push(eq(schema.tasks.projectId, projectId));
  }

  const tasks = await db.query.tasks.findMany({
    where: and(...conditions),
    columns: { id: true, title: true, dueDate: true, priority: true, status: true },
    orderBy: (tasks, { asc }) => [asc(tasks.dueDate)],
    limit: 10,
  });

  return tasks;
}

/**
 * Generate daily check-in message
 */
export async function generateDailyCheckin(
  userId: string,
  projectId: string | null
): Promise<string | null> {
  const todayTasks = await getUpcomingTasks(userId, projectId, 'today');
  const overdueTasks = await getOverdueTasks(userId, projectId);

  if (todayTasks.length === 0 && overdueTasks.length === 0) {
    return null;  // No message needed
  }

  let message = 'Good morning! Here\'s your daily update:\n\n';

  if (overdueTasks.length > 0) {
    message += `**Overdue (${overdueTasks.length}):**\n`;
    message += overdueTasks.slice(0, 3).map(t => `- ${t.title}`).join('\n');
    if (overdueTasks.length > 3) {
      message += `\n  ...and ${overdueTasks.length - 3} more`;
    }
    message += '\n\n';
  }

  if (todayTasks.length > 0) {
    message += `**Due today (${todayTasks.length}):**\n`;
    message += todayTasks.slice(0, 5).map(t => `- ${t.title}`).join('\n');
    if (todayTasks.length > 5) {
      message += `\n  ...and ${todayTasks.length - 5} more`;
    }
  }

  return message;
}

/**
 * Generate overdue alert message
 */
export async function generateOverdueAlert(
  userId: string,
  projectId: string | null
): Promise<string | null> {
  const overdueTasks = await getOverdueTasks(userId, projectId);

  if (overdueTasks.length === 0) {
    return null;
  }

  let message = `You have ${overdueTasks.length} overdue task${overdueTasks.length > 1 ? 's' : ''}:\n\n`;
  message += overdueTasks.slice(0, 5).map(t => {
    const daysOverdue = t.dueDate
      ? Math.floor((Date.now() - t.dueDate.getTime()) / (1000 * 60 * 60 * 24))
      : 0;
    return `- ${t.title} (${daysOverdue} day${daysOverdue > 1 ? 's' : ''} overdue)`;
  }).join('\n');

  if (overdueTasks.length > 5) {
    message += `\n\n...and ${overdueTasks.length - 5} more.`;
  }

  return message;
}

/**
 * Generate weekly recap message
 */
export async function generateWeeklyRecap(
  userId: string,
  projectId: string | null
): Promise<string | null> {
  const now = new Date();
  const weekAgo = new Date(now);
  weekAgo.setDate(weekAgo.getDate() - 7);

  // Count tasks completed this week
  const completedConditions: any[] = [
    eq(schema.tasks.assigneeId, userId),
    eq(schema.tasks.status, 'done'),
    gte(schema.tasks.completedAt, weekAgo),
  ];

  if (projectId) {
    completedConditions.push(eq(schema.tasks.projectId, projectId));
  }

  const [completedCount] = await db
    .select({ count: sql<number>`count(*)` })
    .from(schema.tasks)
    .where(and(...completedConditions));

  // Count tasks created this week
  const createdConditions: any[] = [
    eq(schema.tasks.assigneeId, userId),
    gte(schema.tasks.createdAt, weekAgo),
  ];

  if (projectId) {
    createdConditions.push(eq(schema.tasks.projectId, projectId));
  }

  const [createdCount] = await db
    .select({ count: sql<number>`count(*)` })
    .from(schema.tasks)
    .where(and(...createdConditions));

  // Get upcoming tasks for next week
  const upcomingTasks = await getUpcomingTasks(userId, projectId, 'this_week');

  const completed = Number(completedCount?.count ?? 0);
  const created = Number(createdCount?.count ?? 0);

  let message = 'Weekly Recap:\n\n';
  message += `- Tasks completed: ${completed}\n`;
  message += `- New tasks assigned: ${created}\n`;
  message += `- Tasks due next week: ${upcomingTasks.length}\n`;

  if (completed > created) {
    message += '\nGreat progress! You completed more than you received.';
  } else if (created > completed + 3) {
    message += '\nHeads up: Your backlog is growing. Consider prioritizing.';
  }

  return message;
}
```
  </action>
  <verify>bun run typecheck passes</verify>
  <done>Proactive message content generators for check-ins, alerts, and recaps implemented</done>
</task>

<task type="auto">
  <name>Task 2: Create proactive messaging worker with scheduled jobs</name>
  <files>src/features/messaging/messaging.worker.ts, src/shared/lib/queue/client.ts</files>
  <action>
1. Add proactive messaging queue to src/shared/lib/queue/client.ts:
```typescript
export const proactiveMessagingQueue = new Queue('proactive-messaging', {
  connection: getQueueConnection(),
});

// Update closeQueueConnections
export async function closeQueueConnections(): Promise<void> {
  await memoryConsolidationQueue.close();
  await embeddingQueue.close();
  await notificationQueue.close();
  await proactiveMessagingQueue.close();
  // ... rest
}
```

2. Create messaging.worker.ts:

**IMPORTANT:** Import sendTelegramMessage from the barrel export, NOT from telegram.handlers.ts directly:
```typescript
import { Worker } from 'bullmq';
import { getQueueConnection, proactiveMessagingQueue } from '../../shared/lib/queue/client';
import { registerWorker } from '../../shared/lib/queue/workers';
import { db, schema } from '../../shared/db';
import { eq, and } from 'drizzle-orm';
import {
  generateDailyCheckin,
  generateOverdueAlert,
  generateWeeklyRecap,
} from './messaging.proactive';
// CORRECT import path - from barrel export
import { sendTelegramMessage } from '../telegram';
import { sendWhatsAppMessage } from '../whatsapp/whatsapp.client';
import { logger } from '../../shared/lib/logger';

interface ProactiveJobData {
  type: 'daily_checkin' | 'overdue_alert' | 'weekly_recap';
  userId: string;
}

/**
 * Send proactive message to user via their preferred channel(s)
 */
async function deliverMessage(userId: string, message: string): Promise<void> {
  const userMessaging = await db.query.userMessaging.findFirst({
    where: eq(schema.userMessaging.userId, userId),
  });

  if (!userMessaging?.messagingEnabled) {
    logger.info({ userId }, 'Messaging disabled, skipping proactive message');
    return;
  }

  // Deliver via Telegram
  if (userMessaging.telegramChatId && userMessaging.telegramVerified) {
    try {
      await sendTelegramMessage(userMessaging.telegramChatId, message);
      logger.info({ userId, platform: 'telegram' }, 'Proactive message delivered');
    } catch (err) {
      logger.error({ err, userId }, 'Failed to deliver via Telegram');
    }
  }

  // Deliver via WhatsApp
  if (userMessaging.whatsappPhone && userMessaging.whatsappVerified) {
    try {
      await sendWhatsAppMessage(userMessaging.whatsappPhone, message);
      logger.info({ userId, platform: 'whatsapp' }, 'Proactive message delivered');
    } catch (err) {
      logger.error({ err, userId }, 'Failed to deliver via WhatsApp');
    }
  }
}

/**
 * Proactive messaging worker
 */
export const proactiveMessagingWorker = new Worker<ProactiveJobData>(
  'proactive-messaging',
  async (job) => {
    const { type, userId } = job.data;
    logger.info({ jobId: job.id, type, userId }, 'Processing proactive message');

    // Get user's last project context
    const userMessaging = await db.query.userMessaging.findFirst({
      where: eq(schema.userMessaging.userId, userId),
      columns: { lastProjectId: true, dailyCheckinEnabled: true, weeklyRecapEnabled: true },
    });

    const projectId = userMessaging?.lastProjectId ?? null;

    let message: string | null = null;

    switch (type) {
      case 'daily_checkin':
        if (!userMessaging?.dailyCheckinEnabled) {
          logger.info({ userId }, 'Daily check-in disabled, skipping');
          return;
        }
        message = await generateDailyCheckin(userId, projectId);
        break;

      case 'overdue_alert':
        message = await generateOverdueAlert(userId, projectId);
        break;

      case 'weekly_recap':
        if (!userMessaging?.weeklyRecapEnabled) {
          logger.info({ userId }, 'Weekly recap disabled, skipping');
          return;
        }
        message = await generateWeeklyRecap(userId, projectId);
        break;
    }

    if (!message) {
      logger.info({ type, userId }, 'No proactive message to send');
      return;
    }

    await deliverMessage(userId, message);
  },
  {
    connection: getQueueConnection(),
    concurrency: 5,
  }
);

// Register for graceful shutdown
registerWorker(proactiveMessagingWorker);

/**
 * Schedule proactive messages for all enabled users
 * Called by a cron job or app startup
 */
export async function scheduleAllProactiveMessages(): Promise<void> {
  // Get all users with messaging enabled
  const users = await db.query.userMessaging.findMany({
    where: eq(schema.userMessaging.messagingEnabled, true),
    columns: { userId: true, dailyCheckinEnabled: true, weeklyRecapEnabled: true },
  });

  logger.info({ userCount: users.length }, 'Scheduling proactive messages');

  for (const user of users) {
    // Daily check-in (9 AM)
    if (user.dailyCheckinEnabled) {
      await proactiveMessagingQueue.add(
        'daily-checkin',
        { type: 'daily_checkin', userId: user.userId },
        {
          repeat: {
            pattern: '0 9 * * *',  // 9 AM daily
          },
          jobId: `daily-checkin-${user.userId}`,
        }
      );
    }

    // Weekly recap (Monday 9 AM)
    if (user.weeklyRecapEnabled) {
      await proactiveMessagingQueue.add(
        'weekly-recap',
        { type: 'weekly_recap', userId: user.userId },
        {
          repeat: {
            pattern: '0 9 * * 1',  // 9 AM Monday
          },
          jobId: `weekly-recap-${user.userId}`,
        }
      );
    }
  }
}

/**
 * Queue an immediate overdue alert for a user
 */
export async function queueOverdueAlert(userId: string): Promise<void> {
  await proactiveMessagingQueue.add(
    'overdue-alert',
    { type: 'overdue_alert', userId },
    { attempts: 3, backoff: { type: 'exponential', delay: 1000 } }
  );
}

export { proactiveMessagingQueue };
```

3. Import worker in src/index.ts to ensure it starts:
```typescript
import './features/messaging/messaging.worker';
```
  </action>
  <verify>bun run typecheck passes</verify>
  <done>Proactive messaging worker with scheduled jobs implemented</done>
</task>

<task type="auto">
  <name>Task 3: Create activity feed service and routes</name>
  <files>src/features/notifications/activity-feed.service.ts, src/features/notifications/notifications.routes.ts, src/features/notifications/index.ts</files>
  <action>
1. Create activity-feed.service.ts following RESEARCH.md Activity Feed Query:
```typescript
import { db, schema } from '../../shared/db';
import { sql } from 'drizzle-orm';
import { logger } from '../../shared/lib/logger';

export interface ActivityFeedItem {
  id: string;
  type: string;
  actorId: string | null;
  actorEmail: string | null;
  targetType: string;
  targetId: string;
  targetTitle: string | null;
  projectId: string;
  projectName: string | null;
  createdAt: Date;
}

/**
 * Get activity feed for a project
 */
export async function getActivityFeed(
  projectId: string,
  limit = 50,
  offset = 0
): Promise<ActivityFeedItem[]> {
  const result = await db.execute<{
    id: string;
    type: string;
    actor_id: string | null;
    actor_email: string | null;
    target_type: string;
    target_id: string;
    target_title: string | null;
    project_id: string;
    project_name: string | null;
    created_at: Date;
  }>(sql`
    SELECT
      n.id,
      n.type,
      n.actor_id,
      u.email as actor_email,
      n.target_type,
      n.target_id,
      COALESCE(t.title, d.title) as target_title,
      n.project_id,
      p.name as project_name,
      n.created_at
    FROM notifications n
    LEFT JOIN users u ON n.actor_id = u.id
    LEFT JOIN tasks t ON n.target_type = 'task' AND n.target_id = t.id
    LEFT JOIN deliverables d ON n.target_type = 'deliverable' AND n.target_id = d.id
    LEFT JOIN projects p ON n.project_id = p.id
    WHERE n.project_id = ${projectId}
    ORDER BY n.created_at DESC
    LIMIT ${limit}
    OFFSET ${offset}
  `);

  return (result as unknown as Array<typeof result extends Array<infer T> ? T : never>).map(r => ({
    id: r.id,
    type: r.type,
    actorId: r.actor_id,
    actorEmail: r.actor_email,
    targetType: r.target_type,
    targetId: r.target_id,
    targetTitle: r.target_title,
    projectId: r.project_id,
    projectName: r.project_name,
    createdAt: r.created_at,
  }));
}

/**
 * Get recent activity across all visible projects for a user
 */
export async function getUserActivityFeed(
  visibleProjectIds: string[],
  limit = 50,
  offset = 0
): Promise<ActivityFeedItem[]> {
  if (visibleProjectIds.length === 0) {
    return [];
  }

  const projectList = visibleProjectIds.map(id => `'${id}'`).join(',');

  const result = await db.execute<{
    id: string;
    type: string;
    actor_id: string | null;
    actor_email: string | null;
    target_type: string;
    target_id: string;
    target_title: string | null;
    project_id: string;
    project_name: string | null;
    created_at: Date;
  }>(sql`
    SELECT
      n.id,
      n.type,
      n.actor_id,
      u.email as actor_email,
      n.target_type,
      n.target_id,
      COALESCE(t.title, d.title) as target_title,
      n.project_id,
      p.name as project_name,
      n.created_at
    FROM notifications n
    LEFT JOIN users u ON n.actor_id = u.id
    LEFT JOIN tasks t ON n.target_type = 'task' AND n.target_id = t.id
    LEFT JOIN deliverables d ON n.target_type = 'deliverable' AND n.target_id = d.id
    LEFT JOIN projects p ON n.project_id = p.id
    WHERE n.project_id IN (${sql.raw(projectList)})
    ORDER BY n.created_at DESC
    LIMIT ${limit}
    OFFSET ${offset}
  `);

  return (result as unknown as Array<typeof result extends Array<infer T> ? T : never>).map(r => ({
    id: r.id,
    type: r.type,
    actorId: r.actor_id,
    actorEmail: r.actor_email,
    targetType: r.target_type,
    targetId: r.target_id,
    targetTitle: r.target_title,
    projectId: r.project_id,
    projectName: r.project_name,
    createdAt: r.created_at,
  }));
}
```

2. Add activity feed routes to notifications.routes.ts:
```typescript
import { getActivityFeed, getUserActivityFeed } from './activity-feed.service';
import { visibilityMiddleware } from '../visibility/visibility.middleware';
import { z } from 'zod';

// Add visibility middleware after auth
app.use('/activity*', visibilityMiddleware);

// Get activity feed for a specific project
app.get(
  '/activity/project/:projectId',
  zValidator(
    'query',
    z.object({
      limit: z.coerce.number().min(1).max(100).default(50),
      offset: z.coerce.number().min(0).default(0),
    })
  ),
  async (c) => {
    const projectId = c.req.param('projectId');
    const visibleProjectIds = c.get('visibleProjectIds');
    const { limit, offset } = c.req.valid('query');

    // Verify project visibility
    if (!visibleProjectIds.includes(projectId)) {
      throw new ApiError(403, 'Access denied to project');
    }

    const feed = await getActivityFeed(projectId, limit, offset);
    return c.json({ data: feed });
  }
);

// Get activity feed across all visible projects
app.get(
  '/activity',
  zValidator(
    'query',
    z.object({
      limit: z.coerce.number().min(1).max(100).default(50),
      offset: z.coerce.number().min(0).default(0),
    })
  ),
  async (c) => {
    const visibleProjectIds = c.get('visibleProjectIds');
    const { limit, offset } = c.req.valid('query');

    const feed = await getUserActivityFeed(visibleProjectIds, limit, offset);
    return c.json({ data: feed });
  }
);
```

3. Update notifications/index.ts to export activity feed:
```typescript
export { getActivityFeed, getUserActivityFeed } from './activity-feed.service';
```

4. Update messaging/index.ts to export proactive functions:
```typescript
export {
  proactiveMessagingWorker,
  proactiveMessagingQueue,
  scheduleAllProactiveMessages,
  queueOverdueAlert,
} from './messaging.worker';
export {
  generateDailyCheckin,
  generateOverdueAlert,
  generateWeeklyRecap,
  getUpcomingTasks,
  getOverdueTasks,
} from './messaging.proactive';
```
  </action>
  <verify>bun run typecheck passes, bun run test passes</verify>
  <done>Activity feed service and proactive messaging fully integrated</done>
</task>

</tasks>

<verification>
- [ ] Daily check-in generates message with today's tasks
- [ ] Overdue alert generates message with overdue task count
- [ ] Weekly recap generates summary of completed/created tasks
- [ ] Proactive messages respect user preferences (dailyCheckinEnabled, etc.)
- [ ] GET /api/v1/notifications/activity returns activity feed
- [ ] GET /api/v1/notifications/activity/project/:id returns project feed
- [ ] Activity feed respects visibility middleware
- [ ] **sendTelegramMessage imported from '../telegram' (barrel export)**
- [ ] bun run typecheck and bun run test pass
</verification>

<success_criteria>
- Users with dailyCheckinEnabled=true receive morning check-ins
- Users with weeklyRecapEnabled=true receive Monday recaps
- Overdue alerts can be triggered on-demand
- Activity feed shows recent project activity
- All proactive messages delivered via user's connected channels
</success_criteria>

<output>
After completion, create `.planning/phases/05-messaging-channels/05-07-SUMMARY.md`
</output>
