---
phase: 05-messaging-channels
plan: 06
type: execute
wave: 3
depends_on: ["05-02", "05-03"]
files_modified:
  - src/features/messaging/messaging.types.ts
  - src/features/messaging/messaging.intents.ts
  - src/features/messaging/messaging.context.ts
  - src/features/messaging/messaging.service.ts
  - src/features/messaging/index.ts
  - src/features/telegram/telegram.handlers.ts
  - src/features/whatsapp/whatsapp.handlers.ts
autonomous: true

must_haves:
  truths:
    - "Agent understands 'what's due this week' queries"
    - "Agent understands 'squad status' queries"
    - "Agent understands 'switch to project X' commands"
    - "User's project context persists across messages"
    - "Agent responds with relevant task/deliverable information"
  artifacts:
    - path: "src/features/messaging/messaging.intents.ts"
      provides: "LLM-based intent detection via function calling"
      exports: ["detectIntent"]
    - path: "src/features/messaging/messaging.context.ts"
      provides: "User context management with project switching"
      exports: ["getUserContext", "switchProject"]
    - path: "src/features/messaging/messaging.service.ts"
      provides: "Unified message processing for both platforms"
      exports: ["processMessage"]
  key_links:
    - from: "src/features/messaging/messaging.intents.ts"
      to: "LLM client"
      via: "function calling for intent detection"
      pattern: "createLLMClient|chatCompletionForOrg"
    - from: "src/features/messaging/messaging.service.ts"
      to: "conversations service"
      via: "sendMessage for complex queries"
      pattern: "sendMessage.*conversations"
---

<objective>
Implement natural language understanding and context management for messaging channels.

Purpose: Enable agent to understand natural language queries and maintain project context (MSG-03, MSG-04, MSG-05, MSG-07).
Output: Intent detection service, context manager, and unified message processor.
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-messaging-channels/05-RESEARCH.md

@src/features/llm/llm.service.ts
@src/features/conversations/conversations.service.ts
@src/features/tasks/tasks.service.ts
@src/features/visibility/visibility.service.ts
@src/shared/db/schema/user-messaging.ts
@src/features/telegram/telegram.handlers.ts
@src/features/whatsapp/whatsapp.handlers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create intent detection with LLM function calling</name>
  <files>src/features/messaging/messaging.types.ts, src/features/messaging/messaging.intents.ts</files>
  <action>
1. Create messaging.types.ts:
```typescript
import { z } from 'zod';

export const intentEnum = z.enum([
  'query_tasks',        // "what's due this week?", "my tasks"
  'query_status',       // "squad status", "project progress"
  'create_task',        // "create task X", "add task"
  'update_task',        // "mark task X as done", "complete task"
  'switch_project',     // "/switch", "switch to project X"
  'help',               // "help", "what can you do?"
  'general_chat',       // Conversational, not task-specific
  'unknown'             // Can't determine intent
]);

export type Intent = z.infer<typeof intentEnum>;

export const entitiesSchema = z.object({
  projectName: z.string().optional(),
  taskTitle: z.string().optional(),
  timeRange: z.enum(['today', 'this_week', 'this_month', 'overdue']).optional(),
  status: z.enum(['todo', 'in_progress', 'done']).optional(),
  priority: z.enum(['low', 'medium', 'high', 'urgent']).optional(),
  assignee: z.string().optional(),
});

export type Entities = z.infer<typeof entitiesSchema>;

export const intentResultSchema = z.object({
  intent: intentEnum,
  entities: entitiesSchema,
  confidence: z.number().min(0).max(1),
});

export type IntentResult = z.infer<typeof intentResultSchema>;

export interface MessageContext {
  userId: string;
  organizationId: string;
  currentProjectId: string | null;
  visibleProjectIds: string[];
  conversationId: string | null;
}

export interface ProcessedMessage {
  response: string;
  newProjectId?: string;  // If context switched
}
```

2. Create messaging.intents.ts following RESEARCH.md Pattern 3:
```typescript
import { chatCompletionForOrg } from '../llm';
import { logger } from '../../shared/lib/logger';
import { intentResultSchema, type IntentResult } from './messaging.types';

const INTENT_SYSTEM_PROMPT = `You are a project management assistant. Your job is to classify user messages into intents.

Available intents:
- query_tasks: User asking about tasks ("what's due this week?", "show my tasks", "upcoming deadlines")
- query_status: User asking about project/squad status ("how's the project going?", "squad status", "progress report")
- create_task: User wants to create a task ("create task", "add task", "new task")
- update_task: User wants to update a task ("mark X as done", "complete task", "update status")
- switch_project: User wants to change project context ("switch project", "go to project X", "/switch")
- help: User asking for help ("help", "what can you do?", "commands")
- general_chat: General conversation not about tasks ("hello", "thanks", "how are you")
- unknown: Can't determine what user wants

Extract entities when present:
- projectName: Project name if mentioned
- taskTitle: Task title if mentioned
- timeRange: today, this_week, this_month, or overdue
- status: todo, in_progress, or done
- priority: low, medium, high, or urgent
- assignee: Person name if mentioned`;

const INTENT_FUNCTION = {
  name: 'classify_intent',
  description: 'Classify the user message intent and extract entities',
  parameters: {
    type: 'object',
    properties: {
      intent: {
        type: 'string',
        enum: ['query_tasks', 'query_status', 'create_task', 'update_task', 'switch_project', 'help', 'general_chat', 'unknown'],
        description: 'The classified intent'
      },
      entities: {
        type: 'object',
        properties: {
          projectName: { type: 'string', description: 'Project name if mentioned' },
          taskTitle: { type: 'string', description: 'Task title if mentioned' },
          timeRange: { type: 'string', enum: ['today', 'this_week', 'this_month', 'overdue'] },
          status: { type: 'string', enum: ['todo', 'in_progress', 'done'] },
          priority: { type: 'string', enum: ['low', 'medium', 'high', 'urgent'] },
          assignee: { type: 'string', description: 'Person name if mentioned' },
        },
        required: []
      },
      confidence: {
        type: 'number',
        description: 'Confidence score from 0 to 1',
        minimum: 0,
        maximum: 1
      }
    },
    required: ['intent', 'entities', 'confidence']
  }
};

/**
 * Detect intent from user message using LLM function calling
 */
export async function detectIntent(
  message: string,
  organizationId: string,
  conversationHistory: Array<{ role: 'user' | 'assistant'; content: string }> = []
): Promise<IntentResult> {
  try {
    const response = await chatCompletionForOrg(organizationId, {
      messages: [
        { role: 'system', content: INTENT_SYSTEM_PROMPT },
        ...conversationHistory.slice(-5),  // Include recent context
        { role: 'user', content: message }
      ],
      tools: [{
        type: 'function',
        function: INTENT_FUNCTION
      }],
      tool_choice: { type: 'function', function: { name: 'classify_intent' } }
    });

    const toolCall = response.choices[0]?.message?.tool_calls?.[0];
    if (!toolCall || toolCall.function.name !== 'classify_intent') {
      logger.warn({ message }, 'No intent function call in response');
      return { intent: 'unknown', entities: {}, confidence: 0 };
    }

    const parsed = JSON.parse(toolCall.function.arguments);
    const result = intentResultSchema.safeParse(parsed);

    if (!result.success) {
      logger.warn({ parsed, errors: result.error.issues }, 'Invalid intent result');
      return { intent: 'unknown', entities: {}, confidence: 0 };
    }

    logger.info({ intent: result.data.intent, confidence: result.data.confidence }, 'Intent detected');
    return result.data;

  } catch (err) {
    logger.error({ err, message }, 'Failed to detect intent');
    return { intent: 'unknown', entities: {}, confidence: 0 };
  }
}
```
  </action>
  <verify>bun run typecheck passes</verify>
  <done>Intent detection with LLM function calling implemented</done>
</task>

<task type="auto">
  <name>Task 2: Create context management and message processor</name>
  <files>src/features/messaging/messaging.context.ts, src/features/messaging/messaging.service.ts</files>
  <action>
1. Create messaging.context.ts following RESEARCH.md Pattern 4:
```typescript
import { db, schema } from '../../shared/db';
import { eq, and } from 'drizzle-orm';
import { getVisibleProjectIds } from '../visibility';
import { logger } from '../../shared/lib/logger';
import type { MessageContext } from './messaging.types';

/**
 * Get or create user messaging context
 */
export async function getUserContext(userId: string): Promise<MessageContext | null> {
  const user = await db.query.users.findFirst({
    where: eq(schema.users.id, userId),
    columns: { id: true, orgId: true },
  });

  if (!user) {
    logger.warn({ userId }, 'User not found for messaging context');
    return null;
  }

  // Get user's messaging preferences
  const userMessaging = await db.query.userMessaging.findFirst({
    where: eq(schema.userMessaging.userId, userId),
  });

  // Get visible projects
  const visibleProjectIds = await getVisibleProjectIds(userId, user.orgId);

  // Validate last project is still visible
  let currentProjectId = userMessaging?.lastProjectId ?? null;
  if (currentProjectId && !visibleProjectIds.includes(currentProjectId)) {
    currentProjectId = null;
  }

  return {
    userId,
    organizationId: user.orgId,
    currentProjectId,
    visibleProjectIds,
    conversationId: null,  // Will be set per conversation
  };
}

/**
 * Switch user's current project context
 */
export async function switchProject(
  userId: string,
  projectId: string
): Promise<{ success: boolean; error?: string }> {
  const context = await getUserContext(userId);
  if (!context) {
    return { success: false, error: 'User not found' };
  }

  if (!context.visibleProjectIds.includes(projectId)) {
    return { success: false, error: 'Project not visible to user' };
  }

  await db
    .insert(schema.userMessaging)
    .values({
      userId,
      lastProjectId: projectId,
      updatedAt: new Date(),
    })
    .onConflictDoUpdate({
      target: schema.userMessaging.userId,
      set: {
        lastProjectId: projectId,
        updatedAt: new Date(),
      },
    });

  logger.info({ userId, projectId }, 'Project context switched');
  return { success: true };
}

/**
 * Get projects user can switch to
 */
export async function getAvailableProjects(
  visibleProjectIds: string[]
): Promise<Array<{ id: string; name: string }>> {
  if (visibleProjectIds.length === 0) {
    return [];
  }

  const projects = await db.query.projects.findMany({
    where: (projects, { inArray }) => inArray(projects.id, visibleProjectIds),
    columns: { id: true, name: true },
  });

  return projects;
}
```

2. Create messaging.service.ts:
```typescript
import { db, schema } from '../../shared/db';
import { eq, and, gte, lte, isNull, or } from 'drizzle-orm';
import { detectIntent } from './messaging.intents';
import { getUserContext, switchProject, getAvailableProjects } from './messaging.context';
import { sendMessage as conversationSendMessage, createConversation, getConversation } from '../conversations';
import { logger } from '../../shared/lib/logger';
import type { MessageContext, ProcessedMessage, IntentResult } from './messaging.types';

/**
 * Get tasks due within a time range
 */
async function getTasksForTimeRange(
  userId: string,
  projectId: string | null,
  timeRange: string
): Promise<Array<{ id: string; title: string; dueDate: Date | null; status: string }>> {
  const now = new Date();
  let startDate: Date;
  let endDate: Date;

  switch (timeRange) {
    case 'today':
      startDate = new Date(now.setHours(0, 0, 0, 0));
      endDate = new Date(now.setHours(23, 59, 59, 999));
      break;
    case 'this_week':
      startDate = new Date();
      startDate.setDate(startDate.getDate() - startDate.getDay());
      startDate.setHours(0, 0, 0, 0);
      endDate = new Date(startDate);
      endDate.setDate(endDate.getDate() + 6);
      endDate.setHours(23, 59, 59, 999);
      break;
    case 'this_month':
      startDate = new Date(now.getFullYear(), now.getMonth(), 1);
      endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
      break;
    case 'overdue':
      startDate = new Date(0);  // Beginning of time
      endDate = new Date();
      endDate.setHours(0, 0, 0, 0);  // Before today
      break;
    default:
      startDate = new Date();
      endDate = new Date();
      endDate.setDate(endDate.getDate() + 7);
  }

  const conditions = [
    eq(schema.tasks.assigneeId, userId),
    gte(schema.tasks.dueDate, startDate),
    lte(schema.tasks.dueDate, endDate),
  ];

  if (projectId) {
    conditions.push(eq(schema.tasks.projectId, projectId));
  }

  if (timeRange !== 'overdue') {
    // Exclude completed tasks for non-overdue queries
    conditions.push(
      or(
        isNull(schema.tasks.status),
        eq(schema.tasks.status, 'todo'),
        eq(schema.tasks.status, 'in_progress')
      ) as any
    );
  }

  const tasks = await db.query.tasks.findMany({
    where: and(...conditions),
    columns: { id: true, title: true, dueDate: true, status: true },
    orderBy: (tasks, { asc }) => [asc(tasks.dueDate)],
    limit: 10,
  });

  return tasks;
}

/**
 * Build response for task query intent
 */
async function handleTaskQuery(
  context: MessageContext,
  intent: IntentResult
): Promise<string> {
  const timeRange = intent.entities.timeRange ?? 'this_week';
  const tasks = await getTasksForTimeRange(
    context.userId,
    context.currentProjectId,
    timeRange
  );

  if (tasks.length === 0) {
    const timeLabel = timeRange.replace('_', ' ');
    return `You have no tasks due ${timeLabel}. Great job staying on top of things!`;
  }

  const timeLabel = timeRange.replace('_', ' ');
  let response = `Here are your tasks due ${timeLabel}:\n\n`;

  for (const task of tasks) {
    const dueDateStr = task.dueDate
      ? task.dueDate.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' })
      : 'No due date';
    response += `- ${task.title} (${dueDateStr})\n`;
  }

  if (tasks.length === 10) {
    response += '\n...and possibly more. Check the web app for full list.';
  }

  return response;
}

/**
 * Handle switch project intent
 */
async function handleSwitchProject(
  context: MessageContext,
  intent: IntentResult
): Promise<ProcessedMessage> {
  const projects = await getAvailableProjects(context.visibleProjectIds);

  if (projects.length === 0) {
    return {
      response: "You don't have access to any projects yet.",
    };
  }

  // If project name mentioned, try to match
  if (intent.entities.projectName) {
    const searchName = intent.entities.projectName.toLowerCase();
    const match = projects.find(p =>
      p.name.toLowerCase().includes(searchName) ||
      searchName.includes(p.name.toLowerCase())
    );

    if (match) {
      await switchProject(context.userId, match.id);
      return {
        response: `Switched to project: ${match.name}`,
        newProjectId: match.id,
      };
    } else {
      return {
        response: `Couldn't find a project matching "${intent.entities.projectName}". Available projects:\n\n${projects.map(p => `- ${p.name}`).join('\n')}`,
      };
    }
  }

  // No project specified - show list
  const currentProject = context.currentProjectId
    ? projects.find(p => p.id === context.currentProjectId)
    : null;

  let response = currentProject
    ? `Current project: ${currentProject.name}\n\n`
    : 'No project selected.\n\n';

  response += 'Available projects:\n';
  response += projects.map(p => `- ${p.name}`).join('\n');
  response += '\n\nReply with the project name to switch.';

  return { response };
}

/**
 * Process an incoming message from any platform
 */
export async function processMessage(
  userId: string,
  message: string,
  platform: 'telegram' | 'whatsapp'
): Promise<ProcessedMessage> {
  // Get user context
  const context = await getUserContext(userId);
  if (!context) {
    return { response: 'Unable to load your context. Please try again.' };
  }

  // Detect intent
  const intent = await detectIntent(message, context.organizationId);

  logger.info(
    { userId, intent: intent.intent, confidence: intent.confidence, platform },
    'Processing message'
  );

  // Handle based on intent
  switch (intent.intent) {
    case 'query_tasks':
      return { response: await handleTaskQuery(context, intent) };

    case 'switch_project':
      return handleSwitchProject(context, intent);

    case 'help':
      return {
        response: `I can help you with:\n\n` +
          `- "What's due today/this week?" - See upcoming tasks\n` +
          `- "Switch to [project name]" - Change project context\n` +
          `- "Squad status" - Get project overview\n` +
          `- Ask any question about your tasks!\n\n` +
          `Current project: ${context.currentProjectId ? 'Set' : 'Not set (use switch to select one)'}`
      };

    case 'query_status':
    case 'create_task':
    case 'update_task':
    case 'general_chat':
      // Use conversation service for complex queries
      if (!context.currentProjectId) {
        return {
          response: "Please select a project first. Say 'switch' to see available projects."
        };
      }

      // Get or create conversation
      let conversationId = context.conversationId;
      if (!conversationId) {
        const conv = await createConversation(
          context.userId,
          context.organizationId,
          context.currentProjectId
        );
        conversationId = conv.id;
      }

      // Send message through conversation service
      const result = await conversationSendMessage(
        conversationId,
        message,
        context.organizationId,
        context.userId,
        context.visibleProjectIds,
        context.currentProjectId
      );

      return { response: result.message.content };

    case 'unknown':
    default:
      if (intent.confidence < 0.5) {
        return {
          response: "I'm not sure what you're asking. Try:\n" +
            "- 'What's due this week?'\n" +
            "- 'Switch project'\n" +
            "- 'Help'"
        };
      }
      return { response: "I couldn't understand that. Type 'help' for available commands." };
  }
}
```
  </action>
  <verify>bun run typecheck passes</verify>
  <done>Message processing with intent-based routing and context management implemented</done>
</task>

<task type="auto">
  <name>Task 3: Integrate with Telegram and WhatsApp handlers</name>
  <files>src/features/messaging/index.ts, src/features/telegram/telegram.handlers.ts, src/features/whatsapp/whatsapp.handlers.ts</files>
  <action>
1. Create messaging/index.ts barrel export:
```typescript
export { detectIntent } from './messaging.intents';
export { getUserContext, switchProject, getAvailableProjects } from './messaging.context';
export { processMessage } from './messaging.service';
export type {
  Intent,
  Entities,
  IntentResult,
  MessageContext,
  ProcessedMessage,
} from './messaging.types';
```

2. Update telegram.handlers.ts to use processMessage:
Replace the placeholder in the message:text handler with:
```typescript
import { processMessage } from '../messaging';

// In bot.on('message:text', ...) handler:
bot.on('message:text', async (ctx) => {
  const userId = await getUserIdFromTelegram(ctx.from.id.toString());
  if (!userId) {
    await ctx.reply('Please connect your account first using the web app.');
    return;
  }

  // Process message through NLU pipeline
  const result = await processMessage(userId, ctx.message.text, 'telegram');
  await ctx.reply(result.response);

  // Update session if project changed
  if (result.newProjectId) {
    ctx.session.currentProjectId = result.newProjectId;
  }
});
```

3. Update whatsapp.handlers.ts to use processMessage:
Replace the placeholder in handleIncomingMessage:
```typescript
import { processMessage } from '../messaging';

// In handleIncomingMessage function:
export async function handleIncomingMessage(message: IncomingMessage): Promise<void> {
  logger.info({ messageId: message.messageId, from: message.from }, 'Processing WhatsApp message');

  const userId = await getUserIdFromWhatsApp(message.from);

  if (!userId) {
    await sendWhatsAppMessage(
      message.from,
      'Welcome to BlockBot! To connect your account, please use the web app and click "Connect WhatsApp".'
    );
    return;
  }

  // Process message through NLU pipeline
  const result = await processMessage(userId, message.text, 'whatsapp');
  await sendWhatsAppMessage(message.from, result.response);
}
```
  </action>
  <verify>bun run typecheck passes, bun run test passes</verify>
  <done>NLU pipeline integrated with both messaging platforms</done>
</task>

</tasks>

<verification>
- [ ] Intent detection classifies "what's due this week" as query_tasks
- [ ] Intent detection classifies "switch to ProjectX" as switch_project
- [ ] Context manager retrieves and updates user project context
- [ ] Task queries return relevant tasks based on time range
- [ ] Project switching works via natural language
- [ ] Both Telegram and WhatsApp use processMessage
- [ ] bun run typecheck and bun run test pass
</verification>

<success_criteria>
- User can ask "what's due this week?" and get task list
- User can say "switch to [project]" and context updates
- Agent responds contextually based on current project
- Help command shows available capabilities
- Unknown intents get helpful fallback response
</success_criteria>

<output>
After completion, create `.planning/phases/05-messaging-channels/05-06-SUMMARY.md`
</output>
