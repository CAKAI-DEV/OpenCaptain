---
phase: 05-messaging-channels
plan: 04
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/features/comments/comments.types.ts
  - src/features/comments/comments.service.ts
  - src/features/comments/comments.routes.ts
  - src/features/comments/index.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "User can create comments on tasks"
    - "User can create comments on deliverables"
    - "@mentions in comment text are parsed and resolved to user IDs"
    - "Comments can be listed for a target item"
  artifacts:
    - path: "src/features/comments/comments.service.ts"
      provides: "Comment CRUD with mention parsing"
      exports: ["createComment", "listComments", "parseMentions"]
    - path: "src/features/comments/comments.routes.ts"
      provides: "REST API endpoints"
      contains: "POST.*comments"
  key_links:
    - from: "src/features/comments/comments.service.ts"
      to: "comments table"
      via: "Drizzle insert/query"
      pattern: "db\\.insert.*comments"
    - from: "src/features/comments/comments.service.ts"
      to: "users table"
      via: "@mention resolution"
      pattern: "db\\.query\\.users"
---

<objective>
Implement comments system with @mention parsing for tasks and deliverables.

Purpose: Enable team communication on work items with @mention support (COMM-01, COMM-02).
Output: Comments service with CRUD operations, mention parsing, and REST API.
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-messaging-channels/05-RESEARCH.md

@src/shared/db/schema/comments.ts
@src/shared/db/schema/users.ts
@src/features/tasks/tasks.service.ts
@src/features/deliverables/deliverables.service.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create comments types and service</name>
  <files>src/features/comments/comments.types.ts, src/features/comments/comments.service.ts</files>
  <action>
1. Create comments.types.ts:
```typescript
import { z } from 'zod';

export const createCommentSchema = z.object({
  targetType: z.enum(['task', 'deliverable']),
  targetId: z.string().uuid(),
  content: z.string().min(1).max(10000),
});

export type CreateCommentInput = z.infer<typeof createCommentSchema>;

export interface CommentResult {
  id: string;
  targetType: 'task' | 'deliverable';
  targetId: string;
  content: string;
  authorId: string;
  authorEmail?: string;
  mentions: string[];
  projectId: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface ParsedMention {
  raw: string;      // @john@example.com or @john
  identifier: string;  // john@example.com or john
  userId: string | null;  // Resolved user ID
}
```

2. Create comments.service.ts following RESEARCH.md Pattern 7:

```typescript
import { db, schema } from '../../shared/db';
import { eq, and, desc } from 'drizzle-orm';
import { logger } from '../../shared/lib/logger';
import type { CreateCommentInput, CommentResult, ParsedMention } from './comments.types';

// Regex to match @mentions - handles @email or @username format
const MENTION_REGEX = /@([a-zA-Z0-9._+-]+(?:@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})?)/g;

/**
 * Parse @mentions from comment text
 */
export function parseMentions(content: string): ParsedMention[] {
  const matches = [...content.matchAll(MENTION_REGEX)];
  return matches.map((match) => ({
    raw: match[0],
    identifier: match[1],
    userId: null,
  }));
}

/**
 * Resolve parsed mentions to user IDs within an organization
 */
export async function resolveMentions(
  mentions: ParsedMention[],
  organizationId: string
): Promise<ParsedMention[]> {
  if (mentions.length === 0) return [];

  const resolved: ParsedMention[] = [];

  for (const mention of mentions) {
    // Try to find user by email within org
    const user = await db.query.users.findFirst({
      where: and(
        eq(schema.users.orgId, organizationId),
        eq(schema.users.email, mention.identifier)
      ),
      columns: { id: true },
    });

    resolved.push({
      ...mention,
      userId: user?.id ?? null,
    });
  }

  return resolved;
}

/**
 * Create a comment with @mention parsing
 */
export async function createComment(
  input: CreateCommentInput,
  authorId: string,
  projectId: string,
  organizationId: string
): Promise<CommentResult> {
  // Parse and resolve mentions
  const parsedMentions = parseMentions(input.content);
  const resolvedMentions = await resolveMentions(parsedMentions, organizationId);
  const mentionUserIds = resolvedMentions
    .filter((m) => m.userId !== null)
    .map((m) => m.userId as string);

  // Create comment
  const [comment] = await db
    .insert(schema.comments)
    .values({
      targetType: input.targetType,
      targetId: input.targetId,
      content: input.content,
      authorId,
      projectId,
      mentions: mentionUserIds,
    })
    .returning();

  logger.info(
    { commentId: comment.id, targetType: input.targetType, targetId: input.targetId, mentions: mentionUserIds.length },
    'Comment created'
  );

  return {
    ...comment,
    mentions: mentionUserIds,
  };
}

/**
 * List comments for a target item
 */
export async function listComments(
  targetType: 'task' | 'deliverable',
  targetId: string,
  limit = 50,
  offset = 0
): Promise<CommentResult[]> {
  const comments = await db.query.comments.findMany({
    where: and(
      eq(schema.comments.targetType, targetType),
      eq(schema.comments.targetId, targetId)
    ),
    orderBy: [desc(schema.comments.createdAt)],
    limit,
    offset,
    with: {
      author: {
        columns: { email: true },
      },
    },
  });

  return comments.map((c) => ({
    ...c,
    authorEmail: c.author?.email,
    mentions: (c.mentions as string[]) ?? [],
  }));
}

/**
 * Get a single comment by ID
 */
export async function getComment(commentId: string): Promise<CommentResult | null> {
  const comment = await db.query.comments.findFirst({
    where: eq(schema.comments.id, commentId),
    with: {
      author: {
        columns: { email: true },
      },
    },
  });

  if (!comment) return null;

  return {
    ...comment,
    authorEmail: comment.author?.email,
    mentions: (comment.mentions as string[]) ?? [],
  };
}

/**
 * Delete a comment (only author can delete)
 */
export async function deleteComment(
  commentId: string,
  userId: string
): Promise<boolean> {
  const result = await db
    .delete(schema.comments)
    .where(and(
      eq(schema.comments.id, commentId),
      eq(schema.comments.authorId, userId)
    ))
    .returning({ id: schema.comments.id });

  return result.length > 0;
}
```
  </action>
  <verify>bun run typecheck passes</verify>
  <done>Comments service with CRUD and mention parsing implemented</done>
</task>

<task type="auto">
  <name>Task 2: Create comments routes</name>
  <files>src/features/comments/comments.routes.ts</files>
  <action>
Create comments.routes.ts:

```typescript
import { Hono } from 'hono';
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';
import { authMiddleware, type AuthContext } from '../auth/auth.middleware';
import { visibilityMiddleware } from '../visibility/visibility.middleware';
import {
  createComment,
  listComments,
  getComment,
  deleteComment,
} from './comments.service';
import { createCommentSchema } from './comments.types';
import { ApiError } from '../../shared/types';
import { getTask } from '../tasks/tasks.service';
import { getDeliverable } from '../deliverables/deliverables.service';

const app = new Hono<AuthContext>();

// All routes require auth + visibility context
app.use('*', authMiddleware);
app.use('*', visibilityMiddleware);

// Create comment on a target
app.post(
  '/',
  zValidator('json', createCommentSchema),
  async (c) => {
    const input = c.req.valid('json');
    const userId = c.get('userId');
    const organizationId = c.get('organizationId');
    const visibleProjectIds = c.get('visibleProjectIds');

    // Get target to find projectId and verify visibility
    let projectId: string;

    if (input.targetType === 'task') {
      const task = await getTask(input.targetId);
      if (!task) throw new ApiError(404, 'Task not found');
      if (!visibleProjectIds.includes(task.projectId)) {
        throw new ApiError(403, 'Access denied to task');
      }
      projectId = task.projectId;
    } else {
      const deliverable = await getDeliverable(input.targetId);
      if (!deliverable) throw new ApiError(404, 'Deliverable not found');
      if (!visibleProjectIds.includes(deliverable.projectId)) {
        throw new ApiError(403, 'Access denied to deliverable');
      }
      projectId = deliverable.projectId;
    }

    const comment = await createComment(input, userId, projectId, organizationId);

    return c.json({ data: comment }, 201);
  }
);

// List comments for a target
app.get(
  '/',
  zValidator(
    'query',
    z.object({
      targetType: z.enum(['task', 'deliverable']),
      targetId: z.string().uuid(),
      limit: z.coerce.number().min(1).max(100).default(50),
      offset: z.coerce.number().min(0).default(0),
    })
  ),
  async (c) => {
    const { targetType, targetId, limit, offset } = c.req.valid('query');
    const visibleProjectIds = c.get('visibleProjectIds');

    // Verify target visibility
    if (targetType === 'task') {
      const task = await getTask(targetId);
      if (!task) throw new ApiError(404, 'Task not found');
      if (!visibleProjectIds.includes(task.projectId)) {
        throw new ApiError(403, 'Access denied to task');
      }
    } else {
      const deliverable = await getDeliverable(targetId);
      if (!deliverable) throw new ApiError(404, 'Deliverable not found');
      if (!visibleProjectIds.includes(deliverable.projectId)) {
        throw new ApiError(403, 'Access denied to deliverable');
      }
    }

    const comments = await listComments(targetType, targetId, limit, offset);

    return c.json({ data: comments });
  }
);

// Get single comment
app.get('/:id', async (c) => {
  const commentId = c.req.param('id');
  const visibleProjectIds = c.get('visibleProjectIds');

  const comment = await getComment(commentId);
  if (!comment) throw new ApiError(404, 'Comment not found');

  if (!visibleProjectIds.includes(comment.projectId)) {
    throw new ApiError(403, 'Access denied to comment');
  }

  return c.json({ data: comment });
});

// Delete comment (author only)
app.delete('/:id', async (c) => {
  const commentId = c.req.param('id');
  const userId = c.get('userId');

  const deleted = await deleteComment(commentId, userId);
  if (!deleted) {
    throw new ApiError(404, 'Comment not found or not authorized to delete');
  }

  return c.json({ data: { deleted: true } });
});

export default app;
```
  </action>
  <verify>bun run typecheck passes</verify>
  <done>Comments REST API with visibility enforcement implemented</done>
</task>

<task type="auto">
  <name>Task 3: Create barrel export and register routes</name>
  <files>src/features/comments/index.ts, src/index.ts</files>
  <action>
1. Create index.ts barrel export:
```typescript
export { default as commentsRoutes } from './comments.routes';
export {
  createComment,
  listComments,
  getComment,
  deleteComment,
  parseMentions,
  resolveMentions,
} from './comments.service';
export type { CreateCommentInput, CommentResult, ParsedMention } from './comments.types';
```

2. Register route in src/index.ts:
```typescript
import { commentsRoutes } from './features/comments';

// After other route registrations
app.route('/api/v1/comments', commentsRoutes);
```

3. Add relations to comments schema if not already present:
In src/shared/db/schema/comments.ts, add relations:
```typescript
import { relations } from 'drizzle-orm';

export const commentsRelations = relations(comments, ({ one }) => ({
  author: one(users, {
    fields: [comments.authorId],
    references: [users.id],
  }),
  project: one(projects, {
    fields: [comments.projectId],
    references: [projects.id],
  }),
}));
```

Ensure relations are properly imported in schema index.
  </action>
  <verify>bun run typecheck passes, bun run test passes</verify>
  <done>Comments feature fully integrated with REST API accessible at /api/v1/comments</done>
</task>

</tasks>

<verification>
- [ ] POST /api/v1/comments creates comment with @mention parsing
- [ ] GET /api/v1/comments?targetType=task&targetId=xxx lists comments
- [ ] GET /api/v1/comments/:id returns single comment
- [ ] DELETE /api/v1/comments/:id deletes (author only)
- [ ] Visibility middleware enforces project access
- [ ] @mentions resolved to user IDs in mentions array
- [ ] bun run typecheck and bun run test pass
</verification>

<success_criteria>
- Comments can be created on tasks and deliverables
- @mentions like @user@example.com are parsed and resolved to user IDs
- Only users with project access can view/create comments
- Only comment author can delete their comment
- Comments returned with author email for display
</success_criteria>

<output>
After completion, create `.planning/phases/05-messaging-channels/05-04-SUMMARY.md`
</output>
