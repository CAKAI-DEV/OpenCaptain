---
phase: 05-messaging-channels
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/features/telegram/telegram.bot.ts
  - src/features/telegram/telegram.handlers.ts
  - src/features/telegram/telegram.webhooks.ts
  - src/features/telegram/telegram.types.ts
  - src/features/telegram/index.ts
  - src/index.ts
autonomous: true
user_setup:
  - service: telegram
    why: "Bot token required for Telegram integration"
    env_vars:
      - name: TELEGRAM_BOT_TOKEN
        source: "Telegram BotFather -> /newbot -> Copy token"
    dashboard_config:
      - task: "Set webhook URL via bot.api.setWebhook() after deployment"
        location: "Automatically configured on app startup"

must_haves:
  truths:
    - "Telegram bot receives messages via webhook"
    - "Bot responds to /start command"
    - "Bot responds to /switch command with project selection"
    - "User sessions persist across bot restarts"
  artifacts:
    - path: "src/features/telegram/telegram.bot.ts"
      provides: "grammY bot instance with Redis sessions"
      contains: "createTelegramBot"
    - path: "src/features/telegram/telegram.webhooks.ts"
      provides: "Webhook route for Hono"
      exports: ["telegramWebhook"]
    - path: "src/features/telegram/telegram.handlers.ts"
      provides: "Command handlers and message sending"
      exports: ["registerHandlers", "sendTelegramMessage"]
  key_links:
    - from: "src/features/telegram/telegram.bot.ts"
      to: "ioredis connection"
      via: "getQueueConnection() for session storage"
      pattern: "getQueueConnection"
    - from: "src/features/telegram/telegram.webhooks.ts"
      to: "src/index.ts"
      via: "route registration"
      pattern: "app\\.route.*telegram"
    - from: "src/features/telegram/telegram.handlers.ts"
      to: "telegramBot.api.sendMessage"
      via: "sendTelegramMessage helper"
      pattern: "telegramBot\\.api\\.sendMessage"
---

<objective>
Implement Telegram bot integration using grammY with Redis session storage.

Purpose: Enable users to interact with BlockBot agent via Telegram. This is the primary messaging channel (MSG-02).
Output: Complete Telegram bot with webhook handling, session management, and basic commands.
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-messaging-channels/05-RESEARCH.md

@src/shared/lib/queue/client.ts
@src/shared/lib/env.ts
@src/shared/db/schema/user-messaging.ts
@src/features/conversations/conversations.service.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Telegram bot with grammY and Redis sessions</name>
  <files>src/features/telegram/telegram.types.ts, src/features/telegram/telegram.bot.ts</files>
  <action>
1. Install dependencies:
```bash
bun add grammy @grammyjs/storage-redis
```

2. Create telegram.types.ts:
```typescript
import type { Context, SessionFlavor } from 'grammy';

export interface SessionData {
  currentProjectId: string | null;
  conversationId: string | null;
  lastActivity: number;
}

export type BotContext = Context & SessionFlavor<SessionData>;
```

3. Create telegram.bot.ts following RESEARCH.md Pattern 2:
- Import Bot, session from 'grammy'
- Import RedisAdapter from '@grammyjs/storage-redis'
- Use getQueueConnection() from shared/lib/queue/client (same ioredis as BullMQ)
- Create function createTelegramBot() that returns Bot<BotContext>
- Configure session with:
  - initial: () => ({ currentProjectId: null, conversationId: null, lastActivity: Date.now() })
  - storage: new RedisAdapter<SessionData>({ instance: getQueueConnection() })
  - getSessionKey: (ctx) => ctx.from?.id.toString()

Add guard for missing TELEGRAM_BOT_TOKEN - return null and log warning if not configured.

Export isTelegramConfigured() helper function that checks env.TELEGRAM_BOT_TOKEN exists.
  </action>
  <verify>bun run typecheck passes</verify>
  <done>Telegram bot factory function exists with Redis session storage</done>
</task>

<task type="auto">
  <name>Task 2: Create command handlers, account linking, and sendTelegramMessage helper</name>
  <files>src/features/telegram/telegram.handlers.ts</files>
  <action>
Create telegram.handlers.ts with command handlers:

1. Helper functions:
- getUserIdFromTelegram(telegramChatId: string): Promise<string | null> - looks up user_messaging by telegramChatId
- connectTelegramAccount(telegramChatId: string, userId: string): Promise<{success: boolean; error?: string}> - upserts user_messaging record

2. **CRITICAL: Create sendTelegramMessage helper for use by notification/messaging workers:**
```typescript
import { telegramBot } from './telegram.webhooks';

/**
 * Send a message to a Telegram chat
 * Used by notification and proactive messaging workers
 */
export async function sendTelegramMessage(chatId: string, text: string): Promise<void> {
  if (!telegramBot) {
    throw new Error('Telegram bot not configured');
  }
  await telegramBot.api.sendMessage(chatId, text);
}
```

Note: This creates a circular dependency between handlers and webhooks. To resolve:
- Option A: Move sendTelegramMessage to telegram.bot.ts and have it accept bot as parameter
- Option B: Create telegram.messaging.ts specifically for outbound messaging
- Option C: Use a late-binding pattern where telegramBot is set after initialization

Recommended: Option A - add to telegram.bot.ts:
```typescript
let botInstance: Bot<BotContext> | null = null;

export function createTelegramBot(): Bot<BotContext> | null {
  // ... existing code ...
  botInstance = bot;
  return bot;
}

export function getTelegramBot(): Bot<BotContext> | null {
  return botInstance;
}

export async function sendTelegramMessage(chatId: string, text: string): Promise<void> {
  const bot = getTelegramBot();
  if (!bot) {
    throw new Error('Telegram bot not configured');
  }
  await bot.api.sendMessage(chatId, text);
}
```

Then in telegram.handlers.ts, import from telegram.bot.ts instead.

3. registerHandlers(bot: Bot<BotContext>) function:

/start handler:
- Check for deep link param (ctx.match) starting with "connect_"
- If present, extract userId from param and call connectTelegramAccount
- Reply with success/failure message
- If no param, reply with welcome message and list available commands

/switch handler:
- Get userId from telegramChatId lookup
- If not linked, reply "Please connect your account first"
- Get user's visible projects via visibility service
- Display inline keyboard with project names
- Handle callback query "switch:{projectId}" to update session and user_messaging.lastProjectId

/help handler:
- List available commands and example queries

Message handler (bot.on('message:text')):
- Get userId from telegram lookup
- If not linked, prompt to connect
- For now, reply with placeholder: "Natural language processing coming soon. Use /help to see commands."
- (Full NLU will be added in Plan 06)

Use db queries with Drizzle - import from shared/db.
  </action>
  <verify>bun run typecheck passes</verify>
  <done>Command handlers respond to /start, /switch, /help and text messages; sendTelegramMessage helper exported for workers</done>
</task>

<task type="auto">
  <name>Task 3: Create webhook route and register in app</name>
  <files>src/features/telegram/telegram.webhooks.ts, src/features/telegram/index.ts, src/index.ts</files>
  <action>
1. Create telegram.webhooks.ts:
```typescript
import { Hono } from 'hono';
import { webhookCallback } from 'grammy';
import { createTelegramBot, isTelegramConfigured, getTelegramBot } from './telegram.bot';
import { registerHandlers } from './telegram.handlers';
import { logger } from '../../shared/lib/logger';

const app = new Hono();

// Initialize bot only if configured
if (isTelegramConfigured()) {
  const bot = createTelegramBot();
  if (bot) {
    registerHandlers(bot);
    logger.info('Telegram bot initialized');
  }
}

// Webhook endpoint
app.post('/webhook/telegram', async (c) => {
  const bot = getTelegramBot();
  if (!bot) {
    return c.json({ error: 'Telegram not configured' }, 503);
  }

  return webhookCallback(bot, 'hono')(c);
});

// Health check for webhook status
app.get('/webhook/telegram', (c) => {
  return c.json({
    configured: isTelegramConfigured(),
    status: getTelegramBot() ? 'active' : 'disabled'
  });
});

export default app;
```

2. Create index.ts barrel export:
```typescript
export { default as telegramWebhook } from './telegram.webhooks';
export { isTelegramConfigured, getTelegramBot, sendTelegramMessage } from './telegram.bot';
export { registerHandlers } from './telegram.handlers';
export type { BotContext, SessionData } from './telegram.types';
```

**IMPORTANT:** Export sendTelegramMessage from index.ts so Plans 05-05 and 05-07 can import it as:
```typescript
import { sendTelegramMessage } from '../telegram';
```

3. Register route in src/index.ts:
```typescript
import { telegramWebhook } from './features/telegram';

// After other route registrations
app.route('', telegramWebhook);
```

4. Add webhook URL setter on startup (in index.ts after routes):
```typescript
import { getTelegramBot, isTelegramConfigured } from './features/telegram';
import { env } from './shared/lib/env';

// Set Telegram webhook URL on startup (only in production with configured bot)
if (env.NODE_ENV === 'production' && isTelegramConfigured()) {
  const bot = getTelegramBot();
  if (bot) {
    const webhookUrl = `${env.APP_URL}/webhook/telegram`;
    bot.api.setWebhook(webhookUrl).then(() => {
      logger.info({ webhookUrl }, 'Telegram webhook set');
    }).catch((err) => {
      logger.error({ err }, 'Failed to set Telegram webhook');
    });
  }
}
```
  </action>
  <verify>bun run typecheck passes, bun run test passes, GET /webhook/telegram returns status</verify>
  <done>Telegram webhook route registered, bot initializes on startup when configured</done>
</task>

</tasks>

<verification>
- [ ] grammY and @grammyjs/storage-redis installed
- [ ] Bot gracefully handles missing TELEGRAM_BOT_TOKEN
- [ ] /start, /switch, /help commands respond correctly
- [ ] Session persists currentProjectId in Redis
- [ ] Webhook endpoint accepts POST at /webhook/telegram
- [ ] **sendTelegramMessage function is exported from src/features/telegram/index.ts**
- [ ] bun run typecheck and bun run test pass
</verification>

<success_criteria>
- Telegram bot initializes when TELEGRAM_BOT_TOKEN is set
- /start command works with deep link for account connection
- /switch command shows inline keyboard with user's projects
- Session data persists across bot restarts (stored in Redis)
- App starts without errors when TELEGRAM_BOT_TOKEN is not set
- **sendTelegramMessage is importable by notification and messaging workers**
</success_criteria>

<output>
After completion, create `.planning/phases/05-messaging-channels/05-02-SUMMARY.md`
</output>
