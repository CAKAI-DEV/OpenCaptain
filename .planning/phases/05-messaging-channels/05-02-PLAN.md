---
phase: 05-messaging-channels
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/features/telegram/telegram.bot.ts
  - src/features/telegram/telegram.handlers.ts
  - src/features/telegram/telegram.webhooks.ts
  - src/features/telegram/telegram.types.ts
  - src/features/telegram/index.ts
  - src/index.ts
autonomous: true
user_setup:
  - service: telegram
    why: "Bot token required for Telegram integration"
    env_vars:
      - name: TELEGRAM_BOT_TOKEN
        source: "Telegram BotFather -> /newbot -> Copy token"
    dashboard_config:
      - task: "Set webhook URL via bot.api.setWebhook() after deployment"
        location: "Automatically configured on app startup"

must_haves:
  truths:
    - "Telegram bot receives messages via webhook"
    - "Bot responds to /start command"
    - "Bot responds to /switch command with project selection"
    - "User sessions persist across bot restarts"
  artifacts:
    - path: "src/features/telegram/telegram.bot.ts"
      provides: "grammY bot instance with Redis sessions"
      contains: "createTelegramBot"
    - path: "src/features/telegram/telegram.webhooks.ts"
      provides: "Webhook route for Hono"
      exports: ["telegramWebhook"]
    - path: "src/features/telegram/telegram.handlers.ts"
      provides: "Command and message handlers"
      contains: "registerHandlers"
  key_links:
    - from: "src/features/telegram/telegram.bot.ts"
      to: "ioredis connection"
      via: "getQueueConnection() for session storage"
      pattern: "getQueueConnection"
    - from: "src/features/telegram/telegram.webhooks.ts"
      to: "src/index.ts"
      via: "route registration"
      pattern: "app\\.route.*telegram"
---

<objective>
Implement Telegram bot integration using grammY with Redis session storage.

Purpose: Enable users to interact with BlockBot agent via Telegram. This is the primary messaging channel (MSG-02).
Output: Complete Telegram bot with webhook handling, session management, and basic commands.
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-messaging-channels/05-RESEARCH.md

@src/shared/lib/queue/client.ts
@src/shared/lib/env.ts
@src/shared/db/schema/user-messaging.ts
@src/features/conversations/conversations.service.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Telegram bot with grammY and Redis sessions</name>
  <files>src/features/telegram/telegram.types.ts, src/features/telegram/telegram.bot.ts</files>
  <action>
1. Install dependencies:
```bash
bun add grammy @grammyjs/storage-redis
```

2. Create telegram.types.ts:
```typescript
import type { Context, SessionFlavor } from 'grammy';

export interface SessionData {
  currentProjectId: string | null;
  conversationId: string | null;
  lastActivity: number;
}

export type BotContext = Context & SessionFlavor<SessionData>;
```

3. Create telegram.bot.ts following RESEARCH.md Pattern 2:
- Import Bot, session from 'grammy'
- Import RedisAdapter from '@grammyjs/storage-redis'
- Use getQueueConnection() from shared/lib/queue/client (same ioredis as BullMQ)
- Create function createTelegramBot() that returns Bot<BotContext>
- Configure session with:
  - initial: () => ({ currentProjectId: null, conversationId: null, lastActivity: Date.now() })
  - storage: new RedisAdapter<SessionData>({ instance: getQueueConnection() })
  - getSessionKey: (ctx) => ctx.from?.id.toString()

Add guard for missing TELEGRAM_BOT_TOKEN - return null and log warning if not configured.

Export isTelegramConfigured() helper function that checks env.TELEGRAM_BOT_TOKEN exists.
  </action>
  <verify>bun run typecheck passes</verify>
  <done>Telegram bot factory function exists with Redis session storage</done>
</task>

<task type="auto">
  <name>Task 2: Create command handlers and account linking</name>
  <files>src/features/telegram/telegram.handlers.ts</files>
  <action>
Create telegram.handlers.ts with command handlers:

1. Helper functions:
- getUserIdFromTelegram(telegramChatId: string): Promise<string | null> - looks up user_messaging by telegramChatId
- connectTelegramAccount(telegramChatId: string, userId: string): Promise<{success: boolean; error?: string}> - upserts user_messaging record

2. registerHandlers(bot: Bot<BotContext>) function:

/start handler:
- Check for deep link param (ctx.match) starting with "connect_"
- If present, extract userId from param and call connectTelegramAccount
- Reply with success/failure message
- If no param, reply with welcome message and list available commands

/switch handler:
- Get userId from telegramChatId lookup
- If not linked, reply "Please connect your account first"
- Get user's visible projects via visibility service
- Display inline keyboard with project names
- Handle callback query "switch:{projectId}" to update session and user_messaging.lastProjectId

/help handler:
- List available commands and example queries

Message handler (bot.on('message:text')):
- Get userId from telegram lookup
- If not linked, prompt to connect
- For now, reply with placeholder: "Natural language processing coming soon. Use /help to see commands."
- (Full NLU will be added in Plan 06)

Use db queries with Drizzle - import from shared/db.
  </action>
  <verify>bun run typecheck passes</verify>
  <done>Command handlers respond to /start, /switch, /help and text messages</done>
</task>

<task type="auto">
  <name>Task 3: Create webhook route and register in app</name>
  <files>src/features/telegram/telegram.webhooks.ts, src/features/telegram/index.ts, src/index.ts</files>
  <action>
1. Create telegram.webhooks.ts:
```typescript
import { Hono } from 'hono';
import { webhookCallback } from 'grammy';
import { createTelegramBot, isTelegramConfigured } from './telegram.bot';
import { registerHandlers } from './telegram.handlers';
import { logger } from '../../shared/lib/logger';

const app = new Hono();

// Initialize bot only if configured
let bot: ReturnType<typeof createTelegramBot> | null = null;

if (isTelegramConfigured()) {
  bot = createTelegramBot();
  if (bot) {
    registerHandlers(bot);
    logger.info('Telegram bot initialized');
  }
}

// Webhook endpoint
app.post('/webhook/telegram', async (c) => {
  if (!bot) {
    return c.json({ error: 'Telegram not configured' }, 503);
  }

  return webhookCallback(bot, 'hono')(c);
});

// Health check for webhook status
app.get('/webhook/telegram', (c) => {
  return c.json({
    configured: isTelegramConfigured(),
    status: bot ? 'active' : 'disabled'
  });
});

export default app;
export { bot as telegramBot };
```

2. Create index.ts barrel export:
```typescript
export { default as telegramWebhook, telegramBot } from './telegram.webhooks';
export { isTelegramConfigured } from './telegram.bot';
export type { BotContext, SessionData } from './telegram.types';
```

3. Register route in src/index.ts:
```typescript
import { telegramWebhook } from './features/telegram';

// After other route registrations
app.route('', telegramWebhook);
```

4. Add webhook URL setter on startup (in index.ts after routes):
```typescript
import { telegramBot, isTelegramConfigured } from './features/telegram';
import { env } from './shared/lib/env';

// Set Telegram webhook URL on startup (only in production with configured bot)
if (env.NODE_ENV === 'production' && isTelegramConfigured() && telegramBot) {
  const webhookUrl = `${env.APP_URL}/webhook/telegram`;
  telegramBot.api.setWebhook(webhookUrl).then(() => {
    logger.info({ webhookUrl }, 'Telegram webhook set');
  }).catch((err) => {
    logger.error({ err }, 'Failed to set Telegram webhook');
  });
}
```
  </action>
  <verify>bun run typecheck passes, bun run test passes, GET /webhook/telegram returns status</verify>
  <done>Telegram webhook route registered, bot initializes on startup when configured</done>
</task>

</tasks>

<verification>
- [ ] grammY and @grammyjs/storage-redis installed
- [ ] Bot gracefully handles missing TELEGRAM_BOT_TOKEN
- [ ] /start, /switch, /help commands respond correctly
- [ ] Session persists currentProjectId in Redis
- [ ] Webhook endpoint accepts POST at /webhook/telegram
- [ ] bun run typecheck and bun run test pass
</verification>

<success_criteria>
- Telegram bot initializes when TELEGRAM_BOT_TOKEN is set
- /start command works with deep link for account connection
- /switch command shows inline keyboard with user's projects
- Session data persists across bot restarts (stored in Redis)
- App starts without errors when TELEGRAM_BOT_TOKEN is not set
</success_criteria>

<output>
After completion, create `.planning/phases/05-messaging-channels/05-02-SUMMARY.md`
</output>
