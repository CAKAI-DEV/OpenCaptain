---
phase: 05-messaging-channels
plan: 05
type: execute
wave: 3
depends_on: ["05-02", "05-03", "05-04"]
files_modified:
  - src/features/notifications/notifications.types.ts
  - src/features/notifications/notifications.service.ts
  - src/features/notifications/notifications.worker.ts
  - src/features/notifications/notifications.routes.ts
  - src/features/notifications/index.ts
  - src/shared/lib/queue/client.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "User receives notification when @mentioned in comment"
    - "User receives notification when assigned to task"
    - "User can view their notifications list"
    - "User can mark notifications as read"
    - "Notifications delivered via Telegram or WhatsApp if connected"
  artifacts:
    - path: "src/features/notifications/notifications.worker.ts"
      provides: "BullMQ worker for notification delivery"
      contains: "notificationWorker"
    - path: "src/features/notifications/notifications.service.ts"
      provides: "Notification CRUD and queue operations"
      exports: ["queueNotification", "getUserNotifications", "markRead"]
    - path: "src/features/notifications/notifications.routes.ts"
      provides: "REST API endpoints"
      contains: "GET.*notifications"
  key_links:
    - from: "src/features/notifications/notifications.worker.ts"
      to: "sendTelegramMessage or sendWhatsAppMessage"
      via: "messaging platform dispatch"
      pattern: "sendTelegramMessage|sendWhatsAppMessage"
    - from: "src/features/comments/comments.service.ts"
      to: "notificationQueue"
      via: "queue mention notification"
      pattern: "notificationQueue\\.add"
---

<objective>
Implement notifications system with messaging channel delivery.

Purpose: Deliver real-time notifications for mentions, assignments, and updates via Telegram/WhatsApp (COMM-03).
Output: Notification queue, worker, REST API, and integration with comments service.
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-messaging-channels/05-RESEARCH.md

@src/shared/db/schema/notifications.ts
@src/shared/db/schema/user-messaging.ts
@src/shared/lib/queue/client.ts
@src/shared/lib/queue/workers.ts
@src/features/telegram/telegram.handlers.ts
@src/features/whatsapp/whatsapp.client.ts
@src/features/comments/comments.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notifications types and service</name>
  <files>src/features/notifications/notifications.types.ts, src/features/notifications/notifications.service.ts</files>
  <action>
1. Create notifications.types.ts:
```typescript
import { z } from 'zod';

export const notificationTypes = [
  'mention',        // @mentioned in comment
  'comment',        // Comment on assigned item
  'assignment',     // Assigned to task/deliverable
  'status_change',  // Status changed on assigned item
  'due_soon',       // Upcoming deadline
] as const;

export type NotificationType = typeof notificationTypes[number];

export interface NotificationJobData {
  type: NotificationType;
  userId: string;
  actorId: string | null;  // null for system notifications
  targetType: 'task' | 'deliverable';
  targetId: string;
  projectId: string;
  commentId?: string;
  extra?: Record<string, unknown>;
}

export interface NotificationResult {
  id: string;
  userId: string;
  type: NotificationType;
  actorId: string | null;
  actorEmail?: string;
  targetType: 'task' | 'deliverable';
  targetId: string;
  targetTitle?: string;
  projectId: string;
  projectName?: string;
  commentId: string | null;
  read: boolean;
  createdAt: Date;
}

export const listNotificationsSchema = z.object({
  unreadOnly: z.coerce.boolean().default(false),
  limit: z.coerce.number().min(1).max(100).default(50),
  offset: z.coerce.number().min(0).default(0),
});
```

2. Create notifications.service.ts:
```typescript
import { db, schema } from '../../shared/db';
import { eq, and, desc, sql } from 'drizzle-orm';
import { notificationQueue } from './notifications.worker';
import { logger } from '../../shared/lib/logger';
import type { NotificationJobData, NotificationResult } from './notifications.types';

/**
 * Queue a notification for processing
 */
export async function queueNotification(data: NotificationJobData): Promise<void> {
  await notificationQueue.add('notification', data, {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 1000,
    },
  });
  logger.info({ type: data.type, userId: data.userId }, 'Notification queued');
}

/**
 * Store notification in database
 */
export async function storeNotification(
  data: NotificationJobData
): Promise<string> {
  const [notification] = await db
    .insert(schema.notifications)
    .values({
      userId: data.userId,
      type: data.type,
      actorId: data.actorId,
      targetType: data.targetType,
      targetId: data.targetId,
      projectId: data.projectId,
      commentId: data.commentId ?? null,
      read: false,
    })
    .returning({ id: schema.notifications.id });

  return notification.id;
}

/**
 * Get user's notifications with pagination
 */
export async function getUserNotifications(
  userId: string,
  unreadOnly = false,
  limit = 50,
  offset = 0
): Promise<NotificationResult[]> {
  const conditions = [eq(schema.notifications.userId, userId)];

  if (unreadOnly) {
    conditions.push(eq(schema.notifications.read, false));
  }

  // Use raw SQL for complex join
  const result = await db.execute<{
    id: string;
    user_id: string;
    type: string;
    actor_id: string | null;
    actor_email: string | null;
    target_type: string;
    target_id: string;
    target_title: string | null;
    project_id: string;
    project_name: string | null;
    comment_id: string | null;
    read: boolean;
    created_at: Date;
  }>(sql`
    SELECT
      n.id,
      n.user_id,
      n.type,
      n.actor_id,
      u.email as actor_email,
      n.target_type,
      n.target_id,
      COALESCE(t.title, d.title) as target_title,
      n.project_id,
      p.name as project_name,
      n.comment_id,
      n.read,
      n.created_at
    FROM notifications n
    LEFT JOIN users u ON n.actor_id = u.id
    LEFT JOIN tasks t ON n.target_type = 'task' AND n.target_id = t.id
    LEFT JOIN deliverables d ON n.target_type = 'deliverable' AND n.target_id = d.id
    LEFT JOIN projects p ON n.project_id = p.id
    WHERE n.user_id = ${userId}
    ${unreadOnly ? sql`AND n.read = false` : sql``}
    ORDER BY n.created_at DESC
    LIMIT ${limit}
    OFFSET ${offset}
  `);

  return (result as unknown as Array<typeof result extends Array<infer T> ? T : never>).map((r) => ({
    id: r.id,
    userId: r.user_id,
    type: r.type as NotificationResult['type'],
    actorId: r.actor_id,
    actorEmail: r.actor_email ?? undefined,
    targetType: r.target_type as 'task' | 'deliverable',
    targetId: r.target_id,
    targetTitle: r.target_title ?? undefined,
    projectId: r.project_id,
    projectName: r.project_name ?? undefined,
    commentId: r.comment_id,
    read: r.read,
    createdAt: r.created_at,
  }));
}

/**
 * Get unread notification count
 */
export async function getUnreadCount(userId: string): Promise<number> {
  const [result] = await db
    .select({ count: sql<number>`count(*)` })
    .from(schema.notifications)
    .where(and(
      eq(schema.notifications.userId, userId),
      eq(schema.notifications.read, false)
    ));

  return Number(result?.count ?? 0);
}

/**
 * Mark notification as read
 */
export async function markNotificationRead(
  notificationId: string,
  userId: string
): Promise<boolean> {
  const result = await db
    .update(schema.notifications)
    .set({ read: true })
    .where(and(
      eq(schema.notifications.id, notificationId),
      eq(schema.notifications.userId, userId)
    ))
    .returning({ id: schema.notifications.id });

  return result.length > 0;
}

/**
 * Mark all notifications as read for a user
 */
export async function markAllRead(userId: string): Promise<number> {
  const result = await db
    .update(schema.notifications)
    .set({ read: true })
    .where(and(
      eq(schema.notifications.userId, userId),
      eq(schema.notifications.read, false)
    ))
    .returning({ id: schema.notifications.id });

  return result.length;
}
```
  </action>
  <verify>bun run typecheck passes</verify>
  <done>Notifications service with queue, storage, and retrieval implemented</done>
</task>

<task type="auto">
  <name>Task 2: Create notifications worker with messaging delivery</name>
  <files>src/features/notifications/notifications.worker.ts, src/shared/lib/queue/client.ts</files>
  <action>
1. Add notification queue to src/shared/lib/queue/client.ts:
```typescript
export const notificationQueue = new Queue('notifications', {
  connection: getQueueConnection(),
});

// Update closeQueueConnections to include new queue
export async function closeQueueConnections(): Promise<void> {
  await memoryConsolidationQueue.close();
  await embeddingQueue.close();
  await notificationQueue.close();
  // ... rest of cleanup
}
```

2. Create notifications.worker.ts following RESEARCH.md Pattern 8:
```typescript
import { Worker } from 'bullmq';
import { getQueueConnection, notificationQueue } from '../../shared/lib/queue/client';
import { registerWorker } from '../../shared/lib/queue/workers';
import { db, schema } from '../../shared/db';
import { eq } from 'drizzle-orm';
import { storeNotification } from './notifications.service';
import { sendTelegramMessage } from '../telegram/telegram.handlers';
import { sendWhatsAppMessage } from '../whatsapp/whatsapp.client';
import { logger } from '../../shared/lib/logger';
import type { NotificationJobData } from './notifications.types';

/**
 * Build notification message based on type
 */
function buildMessage(
  type: string,
  actorName: string,
  targetTitle: string
): string {
  switch (type) {
    case 'mention':
      return `${actorName} mentioned you in a comment on "${targetTitle}"`;
    case 'comment':
      return `${actorName} commented on "${targetTitle}"`;
    case 'assignment':
      return `${actorName} assigned you to "${targetTitle}"`;
    case 'status_change':
      return `${actorName} updated the status of "${targetTitle}"`;
    case 'due_soon':
      return `"${targetTitle}" is due soon`;
    default:
      return 'You have a new notification';
  }
}

/**
 * Get actor display name from user ID
 */
async function getActorName(actorId: string | null): Promise<string> {
  if (!actorId) return 'Someone';

  const user = await db.query.users.findFirst({
    where: eq(schema.users.id, actorId),
    columns: { email: true },
  });

  // Use email prefix as display name
  return user?.email?.split('@')[0] ?? 'Someone';
}

/**
 * Get target title (task or deliverable)
 */
async function getTargetTitle(
  targetType: 'task' | 'deliverable',
  targetId: string
): Promise<string> {
  if (targetType === 'task') {
    const task = await db.query.tasks.findFirst({
      where: eq(schema.tasks.id, targetId),
      columns: { title: true },
    });
    return task?.title ?? 'a task';
  } else {
    const deliverable = await db.query.deliverables.findFirst({
      where: eq(schema.deliverables.id, targetId),
      columns: { title: true },
    });
    return deliverable?.title ?? 'a deliverable';
  }
}

/**
 * Notification worker - stores notification and delivers via messaging channels
 */
export const notificationWorker = new Worker<NotificationJobData>(
  'notifications',
  async (job) => {
    const data = job.data;
    logger.info({ jobId: job.id, type: data.type, userId: data.userId }, 'Processing notification');

    // 1. Store notification in database
    await storeNotification(data);

    // 2. Get user's messaging preferences
    const userMessaging = await db.query.userMessaging.findFirst({
      where: eq(schema.userMessaging.userId, data.userId),
    });

    // Skip messaging if user hasn't enabled it
    if (!userMessaging?.messagingEnabled) {
      logger.info({ userId: data.userId }, 'Messaging disabled for user, skipping delivery');
      return;
    }

    // 3. Build notification message
    const actorName = await getActorName(data.actorId);
    const targetTitle = await getTargetTitle(data.targetType, data.targetId);
    const message = buildMessage(data.type, actorName, targetTitle);

    // 4. Deliver via Telegram if connected
    if (userMessaging.telegramChatId && userMessaging.telegramVerified) {
      try {
        await sendTelegramMessage(userMessaging.telegramChatId, message);
        logger.info({ userId: data.userId, platform: 'telegram' }, 'Notification delivered');
      } catch (err) {
        logger.error({ err, userId: data.userId, platform: 'telegram' }, 'Failed to deliver via Telegram');
      }
    }

    // 5. Deliver via WhatsApp if connected
    if (userMessaging.whatsappPhone && userMessaging.whatsappVerified) {
      try {
        await sendWhatsAppMessage(userMessaging.whatsappPhone, message);
        logger.info({ userId: data.userId, platform: 'whatsapp' }, 'Notification delivered');
      } catch (err) {
        logger.error({ err, userId: data.userId, platform: 'whatsapp' }, 'Failed to deliver via WhatsApp');
      }
    }
  },
  {
    connection: getQueueConnection(),
    concurrency: 10,
  }
);

// Register worker for graceful shutdown
registerWorker(notificationWorker);

export { notificationQueue };
```

3. Add sendTelegramMessage helper to telegram.handlers.ts if not already exported:
```typescript
import { telegramBot } from './telegram.webhooks';

export async function sendTelegramMessage(chatId: string, text: string): Promise<void> {
  if (!telegramBot) {
    throw new Error('Telegram bot not configured');
  }
  await telegramBot.api.sendMessage(chatId, text);
}
```
  </action>
  <verify>bun run typecheck passes</verify>
  <done>Notification worker delivers to Telegram and WhatsApp</done>
</task>

<task type="auto">
  <name>Task 3: Create routes and integrate with comments</name>
  <files>src/features/notifications/notifications.routes.ts, src/features/notifications/index.ts, src/features/comments/comments.service.ts, src/index.ts</files>
  <action>
1. Create notifications.routes.ts:
```typescript
import { Hono } from 'hono';
import { zValidator } from '@hono/zod-validator';
import { authMiddleware, type AuthContext } from '../auth/auth.middleware';
import {
  getUserNotifications,
  getUnreadCount,
  markNotificationRead,
  markAllRead,
} from './notifications.service';
import { listNotificationsSchema } from './notifications.types';
import { ApiError } from '../../shared/types';

const app = new Hono<AuthContext>();

app.use('*', authMiddleware);

// Get user's notifications
app.get(
  '/',
  zValidator('query', listNotificationsSchema),
  async (c) => {
    const userId = c.get('userId');
    const { unreadOnly, limit, offset } = c.req.valid('query');

    const notifications = await getUserNotifications(userId, unreadOnly, limit, offset);

    return c.json({ data: notifications });
  }
);

// Get unread count
app.get('/unread-count', async (c) => {
  const userId = c.get('userId');
  const count = await getUnreadCount(userId);
  return c.json({ data: { count } });
});

// Mark notification as read
app.patch('/:id/read', async (c) => {
  const notificationId = c.req.param('id');
  const userId = c.get('userId');

  const success = await markNotificationRead(notificationId, userId);
  if (!success) {
    throw new ApiError(404, 'Notification not found');
  }

  return c.json({ data: { read: true } });
});

// Mark all as read
app.post('/read-all', async (c) => {
  const userId = c.get('userId');
  const count = await markAllRead(userId);
  return c.json({ data: { markedRead: count } });
});

export default app;
```

2. Create index.ts barrel export:
```typescript
export { default as notificationsRoutes } from './notifications.routes';
export { notificationWorker, notificationQueue } from './notifications.worker';
export {
  queueNotification,
  storeNotification,
  getUserNotifications,
  getUnreadCount,
  markNotificationRead,
  markAllRead,
} from './notifications.service';
export type { NotificationJobData, NotificationResult, NotificationType } from './notifications.types';
```

3. Update comments.service.ts to queue notifications on comment creation:
After creating comment, add:
```typescript
import { queueNotification } from '../notifications';

// In createComment function, after comment is created:

// Queue notifications for mentioned users
for (const mentionUserId of mentionUserIds) {
  if (mentionUserId !== authorId) {  // Don't notify yourself
    await queueNotification({
      type: 'mention',
      userId: mentionUserId,
      actorId: authorId,
      targetType: input.targetType,
      targetId: input.targetId,
      projectId,
      commentId: comment.id,
    });
  }
}

// Notify assignee if commenting on their item (except self)
// Get assignee from target
let assigneeId: string | null = null;
if (input.targetType === 'task') {
  const task = await db.query.tasks.findFirst({
    where: eq(schema.tasks.id, input.targetId),
    columns: { assigneeId: true },
  });
  assigneeId = task?.assigneeId ?? null;
} else {
  const deliverable = await db.query.deliverables.findFirst({
    where: eq(schema.deliverables.id, input.targetId),
    columns: { assigneeId: true },
  });
  assigneeId = deliverable?.assigneeId ?? null;
}

if (assigneeId && assigneeId !== authorId && !mentionUserIds.includes(assigneeId)) {
  await queueNotification({
    type: 'comment',
    userId: assigneeId,
    actorId: authorId,
    targetType: input.targetType,
    targetId: input.targetId,
    projectId,
    commentId: comment.id,
  });
}
```

4. Register route in src/index.ts:
```typescript
import { notificationsRoutes } from './features/notifications';

app.route('/api/v1/notifications', notificationsRoutes);
```

5. Import worker in index.ts to ensure it starts:
```typescript
import './features/notifications/notifications.worker';
```
  </action>
  <verify>bun run typecheck passes, bun run test passes</verify>
  <done>Notifications integrated with comments, routes registered, worker running</done>
</task>

</tasks>

<verification>
- [ ] GET /api/v1/notifications returns user's notifications
- [ ] GET /api/v1/notifications/unread-count returns count
- [ ] PATCH /api/v1/notifications/:id/read marks as read
- [ ] POST /api/v1/notifications/read-all marks all as read
- [ ] Creating comment with @mention queues notification
- [ ] Worker stores notification and delivers via messaging
- [ ] bun run typecheck and bun run test pass
</verification>

<success_criteria>
- Notification created when user @mentioned in comment
- Notification created when someone comments on assigned item
- Notifications delivered via Telegram if user has linked account
- Notifications delivered via WhatsApp if user has linked account
- User can view and manage their notifications via REST API
</success_criteria>

<output>
After completion, create `.planning/phases/05-messaging-channels/05-05-SUMMARY.md`
</output>
