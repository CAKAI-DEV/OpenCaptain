---
phase: 08-workflow-builder-integrations
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - web/src/app/(dashboard)/projects/[projectId]/workflows/page.tsx
  - web/src/lib/api/workflows.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Workflow page fetches configuration on load"
    - "Workflow page saves configuration to backend on save"
    - "Workflow persists across page refresh"
  artifacts:
    - path: "web/src/lib/api/workflows.ts"
      provides: "API client for workflow endpoints"
      exports: ["fetchWorkflow", "saveWorkflow"]
    - path: "web/src/app/(dashboard)/projects/[projectId]/workflows/page.tsx"
      provides: "Workflows page wired to backend"
      contains: "fetchWorkflow"
  key_links:
    - from: "web/src/app/(dashboard)/projects/[projectId]/workflows/page.tsx"
      to: "web/src/lib/api/workflows.ts"
      via: "fetchWorkflow and saveWorkflow calls"
      pattern: "fetchWorkflow|saveWorkflow"
---

<objective>
Wire the workflow editor page to fetch and save configurations via the backend API.

Purpose: Close Gap 1 frontend part - page currently has TODOs and only logs to console
Output: Workflow configurations load on page load and persist when saved
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/08-workflow-builder-integrations/08-VERIFICATION.md
@.planning/phases/08-workflow-builder-integrations/08-01-SUMMARY.md

# Current implementation (has TODOs)
@web/src/app/(dashboard)/projects/[projectId]/workflows/page.tsx
@web/src/components/workflow/workflow-editor.tsx

# Reference API pattern
@web/src/lib/api/tasks.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create workflow API client and wire page</name>
  <files>
    web/src/lib/api/workflows.ts
    web/src/app/(dashboard)/projects/[projectId]/workflows/page.tsx
  </files>
  <action>
Create `web/src/lib/api/workflows.ts`:

```typescript
import type { Edge } from '@xyflow/react';
import type { WorkflowNode } from '@/lib/workflow/types';

interface WorkflowResponse {
  data: {
    workflow: {
      id: string;
      name: string;
      createdAt: string;
      updatedAt: string;
    } | null;
    nodes: WorkflowNode[];
    edges: Edge[];
  };
}

/**
 * Fetch workflow configuration for a project.
 */
export async function fetchWorkflow(projectId: string): Promise<{
  nodes: WorkflowNode[];
  edges: Edge[];
}> {
  const res = await fetch(`/api/v1/projects/${projectId}/workflows`, {
    credentials: 'include',
  });

  if (!res.ok) {
    throw new Error(`Failed to fetch workflow: ${res.status}`);
  }

  const data: WorkflowResponse = await res.json();
  return {
    nodes: data.data.nodes,
    edges: data.data.edges,
  };
}

/**
 * Save workflow configuration for a project.
 */
export async function saveWorkflow(
  projectId: string,
  nodes: WorkflowNode[],
  edges: Edge[]
): Promise<void> {
  const res = await fetch(`/api/v1/projects/${projectId}/workflows`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    credentials: 'include',
    body: JSON.stringify({ nodes, edges }),
  });

  if (!res.ok) {
    throw new Error(`Failed to save workflow: ${res.status}`);
  }
}
```

Update `web/src/app/(dashboard)/projects/[projectId]/workflows/page.tsx` to use the API:

```tsx
import { WorkflowEditor } from '@/components/workflow';
import { fetchWorkflow, saveWorkflow } from '@/lib/api/workflows';
import '@xyflow/react/dist/style.css';

interface WorkflowsPageProps {
  params: Promise<{ projectId: string }>;
}

export default async function WorkflowsPage({ params }: WorkflowsPageProps) {
  const { projectId } = await params;

  // Fetch existing workflow configuration
  let initialNodes: WorkflowNode[] = [];
  let initialEdges: Edge[] = [];

  try {
    const workflow = await fetchWorkflow(projectId);
    initialNodes = workflow.nodes;
    initialEdges = workflow.edges;
  } catch (err) {
    // No workflow yet or error - start with empty canvas
    console.error('Failed to load workflow:', err);
  }

  return (
    <div className="h-[calc(100vh-4rem)]">
      <WorkflowEditor
        initialNodes={initialNodes}
        initialEdges={initialEdges}
        onSave={async (nodes, edges) => {
          'use server';
          await saveWorkflow(projectId, nodes, edges);
        }}
      />
    </div>
  );
}
```

Wait - the page is a Server Component, but onSave is a callback that gets passed to a Client Component. Server Actions can't be passed as props like this. We need a different approach.

Update the page to be a Client Component that handles the save internally:

```tsx
'use client';

import type { Edge } from '@xyflow/react';
import '@xyflow/react/dist/style.css';
import { useEffect, useState } from 'react';
import { WorkflowEditor } from '@/components/workflow';
import { fetchWorkflow, saveWorkflow } from '@/lib/api/workflows';
import type { WorkflowNode } from '@/lib/workflow/types';
import { useParams } from 'next/navigation';
import { toast } from 'sonner';

export default function WorkflowsPage() {
  const params = useParams();
  const projectId = params.projectId as string;

  const [initialNodes, setInitialNodes] = useState<WorkflowNode[]>([]);
  const [initialEdges, setInitialEdges] = useState<Edge[]>([]);
  const [loading, setLoading] = useState(true);

  // Fetch workflow on mount
  useEffect(() => {
    async function loadWorkflow() {
      try {
        const workflow = await fetchWorkflow(projectId);
        setInitialNodes(workflow.nodes);
        setInitialEdges(workflow.edges);
      } catch (err) {
        // No workflow yet or error - start with empty canvas
        console.error('Failed to load workflow:', err);
      } finally {
        setLoading(false);
      }
    }
    loadWorkflow();
  }, [projectId]);

  const handleSave = async (nodes: WorkflowNode[], edges: Edge[]) => {
    try {
      await saveWorkflow(projectId, nodes, edges);
      toast.success('Workflow saved');
    } catch (err) {
      console.error('Failed to save workflow:', err);
      toast.error('Failed to save workflow');
    }
  };

  if (loading) {
    return (
      <div className="h-[calc(100vh-4rem)] flex items-center justify-center">
        <div className="text-muted-foreground">Loading workflow...</div>
      </div>
    );
  }

  return (
    <div className="h-[calc(100vh-4rem)]">
      <WorkflowEditor
        initialNodes={initialNodes}
        initialEdges={initialEdges}
        onSave={handleSave}
      />
    </div>
  );
}
```

This approach:
- Uses useParams() to get projectId (client-side routing)
- Fetches workflow on mount with useEffect
- Shows loading state while fetching
- Saves via onSave callback with toast feedback
  </action>
  <verify>
- `bun run --cwd web typecheck` passes
- `bun run --cwd web lint` passes
- `grep -l "fetchWorkflow" web/src/app/\(dashboard\)/projects/\[projectId\]/workflows/page.tsx` shows it's wired
  </verify>
  <done>
Workflow page fetches configuration on load and saves to backend with toast feedback
  </done>
</task>

</tasks>

<verification>
1. Page loads workflow from backend on mount
2. Save button calls POST to backend
3. Toast shows success/error feedback
4. Type checking passes

```bash
bun run --cwd web typecheck && bun run --cwd web lint
```
</verification>

<success_criteria>
- Workflow page uses fetchWorkflow on mount
- Workflow page uses saveWorkflow on save
- Loading state shown while fetching
- Toast feedback on save success/failure
- No TODOs remaining in page
</success_criteria>

<output>
After completion, create `.planning/phases/08-workflow-builder-integrations/08-07-SUMMARY.md`
</output>
