---
phase: 08-workflow-builder-integrations
plan: 08
type: execute
wave: 1
depends_on: []
files_modified:
  - src/features/messaging/messaging.service.ts
  - src/features/telegram/telegram.handlers.ts
  - src/features/whatsapp/whatsapp.handlers.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Agent automatically detects actionable items from conversation context"
    - "Detected actionable items are presented to user as suggestions"
    - "User can confirm actionable items to create tasks"
  artifacts:
    - path: "src/features/messaging/messaging.service.ts"
      provides: "Integration of detectActionableItems into message flow"
      contains: "detectActionableItems"
  key_links:
    - from: "src/features/messaging/messaging.service.ts"
      to: "src/features/messaging/messaging.task-extraction.ts"
      via: "detectActionableItems import and call"
      pattern: "detectActionableItems"
---

<objective>
Wire the detectActionableItems function into the message processing flow to automatically suggest tasks.

Purpose: Close Gap 2 from verification - function exists but never called in message handlers
Output: Agent proactively suggests actionable items detected from conversation
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/08-workflow-builder-integrations/08-VERIFICATION.md
@.planning/phases/08-workflow-builder-integrations/08-04-SUMMARY.md

# Current implementation (function exists but not called)
@src/features/messaging/messaging.task-extraction.ts
@src/features/messaging/messaging.service.ts
@src/features/messaging/messaging.types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire detectActionableItems into processMessage flow</name>
  <files>
    src/features/messaging/messaging.service.ts
  </files>
  <action>
Update `src/features/messaging/messaging.service.ts` to call `detectActionableItems` during general conversation processing:

1. Add import for `detectActionableItems`:
```typescript
import { detectActionableItems, extractTaskFromMessage } from './messaging.task-extraction';
```

2. Create a helper function to format actionable items as a suggestion message:
```typescript
/**
 * Format actionable items as suggestions for the user.
 */
function formatActionableItemsSuggestion(items: ActionableItem[]): string {
  if (items.length === 0) return '';

  let message = '\n\n---\nI noticed some actionable items:\n';
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    message += `${i + 1}. "${item.suggestedTitle}"\n`;
  }
  message += '\nWould you like me to create tasks for any of these? Reply with the number(s).';
  return message;
}
```

3. Add import for ActionableItem type:
```typescript
import type {
  ActionableItem,
  IntentResult,
  MessageContext,
  PendingTaskConfirmation,
  ProcessedMessage,
  TaskExtractionResult,
} from './messaging.types';
```

4. In the `processMessage` function, after handling `general_chat` intent, check for actionable items. Modify the `general_chat` case to detect actionable items if the response doesn't already contain task-related content:

In the `case 'query_status':`, `case 'update_task':`, and `case 'general_chat':` block, after getting the conversation response, check for actionable items:

```typescript
case 'query_status':
case 'update_task':
case 'general_chat': {
  // Use conversation service for complex queries
  if (!context.currentProjectId) {
    return {
      response: "Please select a project first. Say 'switch' to see available projects.",
    };
  }

  // Get or create conversation
  let conversationId = context.conversationId;
  if (!conversationId) {
    conversationId = await createConversation({
      userId: context.userId,
      organizationId: context.organizationId,
      projectId: context.currentProjectId,
    });
  }

  // Send message through conversation service
  const result = await conversationSendMessage(
    conversationId,
    message,
    context.organizationId,
    context.userId,
    context.visibleProjectIds,
    context.currentProjectId
  );

  let response = result.message.content;

  // For general chat, check for actionable items in recent conversation
  if (intent.intent === 'general_chat' && intent.confidence > 0.6) {
    try {
      // Detect actionable items from the current message
      const actionableItems = await detectActionableItems([message]);
      if (actionableItems.length > 0) {
        response += formatActionableItemsSuggestion(actionableItems);

        // Store actionable items in context for follow-up
        // (reusing pending confirmation pattern but for actionable items)
        logger.info(
          { userId: context.userId, itemCount: actionableItems.length },
          'Actionable items detected in conversation'
        );
      }
    } catch (err) {
      // Don't fail the response if actionable item detection fails
      logger.warn({ err }, 'Failed to detect actionable items');
    }
  }

  return { response };
}
```

Note: We're keeping this simple for MVP - just appending suggestions to the response. A more sophisticated implementation could store the actionable items and handle "create task 1" follow-ups, but that's beyond gap closure scope.
  </action>
  <verify>
- `bun run typecheck` passes
- `bun run lint` passes
- `grep "detectActionableItems" src/features/messaging/messaging.service.ts` shows function is called
  </verify>
  <done>
detectActionableItems is called during general_chat processing and suggestions are appended to responses when items are found
  </done>
</task>

</tasks>

<verification>
1. detectActionableItems is imported and called in messaging.service.ts
2. Actionable items are formatted as suggestions in the response
3. Logging tracks when items are detected
4. Errors don't break the main response flow

```bash
bun run typecheck && bun run lint
```
</verification>

<success_criteria>
- detectActionableItems called during general_chat intent processing
- Suggestions formatted and appended to response when items detected
- Error handling prevents failures from breaking main flow
- Type checks and lint pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-workflow-builder-integrations/08-08-SUMMARY.md`
</output>
