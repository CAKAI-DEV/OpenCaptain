---
phase: 02-team-access
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/shared/db/schema/visibility-grants.ts
  - src/shared/db/schema/index.ts
  - src/shared/lib/permissions/abilities.ts
  - src/shared/lib/permissions/index.ts
  - src/features/visibility/visibility.types.ts
  - src/features/visibility/visibility.service.ts
  - src/features/visibility/visibility.middleware.ts
  - src/features/visibility/visibility.routes.ts
  - src/features/visibility/index.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Default visibility is project-wide (everyone sees everything in their project)"
    - "Admin can restrict users to squad-scoped visibility"
    - "Restricted users see work items only from their squads"
    - "Admin can grant cross-squad visibility to specific users"
    - "All data queries respect visibility rules"
  artifacts:
    - path: "src/shared/db/schema/visibility-grants.ts"
      provides: "Cross-squad visibility grants"
      contains: "granteeUserId"
    - path: "src/shared/lib/permissions/abilities.ts"
      provides: "CASL ability definitions"
      exports: ["defineAbilitiesFor", "AppAbility"]
    - path: "src/features/visibility/visibility.middleware.ts"
      provides: "Middleware that adds visibility filters to context"
      contains: "c.set('visibleSquadIds'"
    - path: "src/features/visibility/visibility.service.ts"
      provides: "Visibility grant management"
      exports: ["grantVisibility", "revokeVisibility", "computeVisibleSquads"]
  key_links:
    - from: "src/features/visibility/visibility.middleware.ts"
      to: "src/shared/lib/permissions/abilities.ts"
      via: "CASL ability building"
      pattern: "defineAbilitiesFor"
    - from: "src/features/visibility/visibility.middleware.ts"
      to: "src/features/visibility/visibility.service.ts"
      via: "Squad computation"
      pattern: "computeVisibleSquads"
---

<objective>
Implement visibility rules with CASL authorization and middleware enforcement.

Purpose: Enable admins to configure visibility (VISB-01), enforce squad-scoped default (VISB-02), allow cross-squad grants (VISB-03), ensure PM/admin have project-wide visibility (VISB-04), and enforce visibility in all queries (VISB-05).

Output: Working visibility middleware, CASL abilities, and grant management endpoints.
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-team-access/02-RESEARCH.md
@.planning/phases/02-team-access/02-CONTEXT.md
@.planning/phases/02-team-access/02-01-SUMMARY.md
@.planning/phases/02-team-access/02-02-SUMMARY.md
@src/shared/lib/permissions/roles.ts
@src/shared/db/schema/squads.ts
@src/shared/db/schema/squad-members.ts
@src/shared/db/schema/project-members.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create visibility grants schema and CASL abilities</name>
  <files>
    src/shared/db/schema/visibility-grants.ts
    src/shared/db/schema/index.ts
    src/shared/lib/permissions/abilities.ts
    src/shared/lib/permissions/index.ts
  </files>
  <action>
Install CASL: `bun add @casl/ability`

**visibility-grants.ts:**
```typescript
import { pgTable, uuid, timestamp, unique } from 'drizzle-orm/pg-core';
import { users } from './users';
import { squads } from './squads';

export const visibilityGrants = pgTable('visibility_grants', {
  id: uuid('id').primaryKey().defaultRandom(),
  granteeUserId: uuid('grantee_user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  squadId: uuid('squad_id').notNull().references(() => squads.id, { onDelete: 'cascade' }),
  grantedById: uuid('granted_by_id').references(() => users.id),
  expiresAt: timestamp('expires_at', { withTimezone: true }), // NULL = permanent
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
}, (table) => ({
  uniqueGrant: unique().on(table.granteeUserId, table.squadId),
}));
```

Update src/shared/db/schema/index.ts to export visibilityGrants.

Run migrations: `bun run db:generate && bun run db:migrate`

**abilities.ts:**
```typescript
import { AbilityBuilder, createMongoAbility, type MongoAbility, type MongoQuery } from '@casl/ability';

type Actions = 'create' | 'read' | 'update' | 'delete' | 'manage';
type Subjects = 'Project' | 'Squad' | 'User' | 'WorkItem' | 'all';

export type AppAbility = MongoAbility<[Actions, Subjects]>;

export interface UserContext {
  id: string;
  orgId: string;
  projectRoles: Array<{ projectId: string; role: string }>;
  squadMemberships: Array<{ squadId: string; isLead: boolean }>;
  visibilityGrants: Array<{ squadId: string }>;
  restrictedToSquad: boolean; // From user settings
}

export function defineAbilitiesFor(user: UserContext): AppAbility {
  const { can, cannot, build } = new AbilityBuilder<AppAbility>(createMongoAbility);

  // Org admin can do everything
  const isOrgAdmin = user.projectRoles.some(pr => pr.role === 'admin');
  if (isOrgAdmin) {
    can('manage', 'all');
    return build();
  }

  // PM has project-wide visibility (per VISB-04)
  const pmProjects = user.projectRoles
    .filter(pr => pr.role === 'pm')
    .map(pr => pr.projectId);

  if (pmProjects.length > 0) {
    can('read', 'WorkItem', { projectId: { $in: pmProjects } });
    can('read', 'User', { projectId: { $in: pmProjects } });
    can('read', 'Squad', { projectId: { $in: pmProjects } });
  }

  // If not restricted to squad, user sees full project (default per CONTEXT)
  if (!user.restrictedToSquad) {
    const allProjects = user.projectRoles.map(pr => pr.projectId);
    can('read', 'WorkItem', { projectId: { $in: allProjects } });
    can('read', 'User', { projectId: { $in: allProjects } });
    can('read', 'Squad', { projectId: { $in: allProjects } });
  } else {
    // Restricted: Only see own squads + granted squads
    const leadSquads = user.squadMemberships
      .filter(sm => sm.isLead)
      .map(sm => sm.squadId);
    const memberSquads = user.squadMemberships.map(sm => sm.squadId);
    const grantedSquads = user.visibilityGrants.map(vg => vg.squadId);
    const visibleSquads = [...new Set([...leadSquads, ...memberSquads, ...grantedSquads])];

    if (visibleSquads.length > 0) {
      can('read', 'WorkItem', { squadId: { $in: visibleSquads } });
    }
    // User names remain visible per CONTEXT decision
    const allProjects = user.projectRoles.map(pr => pr.projectId);
    can('read', 'User', { projectId: { $in: allProjects } });
  }

  // Squad leads can manage their squad members
  const leadSquadIds = user.squadMemberships
    .filter(sm => sm.isLead)
    .map(sm => sm.squadId);
  if (leadSquadIds.length > 0) {
    can('update', 'Squad', { id: { $in: leadSquadIds } });
  }

  return build();
}
```

**src/shared/lib/permissions/index.ts:**
```typescript
export * from './roles';
export * from './abilities';
```
  </action>
  <verify>
`bun run db:migrate` succeeds.
`psql $DATABASE_URL -c "\dt"` shows visibility_grants table.
`bun run typecheck` passes.
  </verify>
  <done>
Visibility grants table exists. CASL abilities defined with project-wide default and squad-scoped restriction support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create visibility service and middleware</name>
  <files>
    src/features/visibility/visibility.types.ts
    src/features/visibility/visibility.service.ts
    src/features/visibility/visibility.middleware.ts
  </files>
  <action>
Create src/features/visibility/ directory:

**visibility.types.ts:**
```typescript
export interface GrantVisibilityInput {
  granteeUserId: string;
  squadId: string;
  grantedById: string;
  expiresAt?: Date;
}

export interface UserVisibilityContext {
  isAdmin: boolean;
  isPM: boolean;
  isRestricted: boolean;
  visibleSquadIds: string[];
  visibleProjectIds: string[];
}
```

**visibility.service.ts:**
```typescript
import { eq, and, or, gt, isNull } from 'drizzle-orm';
import { db, schema } from '../../shared/db';
import type { GrantVisibilityInput, UserVisibilityContext } from './visibility.types';

export async function grantVisibility(input: GrantVisibilityInput) {
  const [grant] = await db.insert(schema.visibilityGrants).values({
    granteeUserId: input.granteeUserId,
    squadId: input.squadId,
    grantedById: input.grantedById,
    expiresAt: input.expiresAt,
  }).onConflictDoUpdate({
    target: [schema.visibilityGrants.granteeUserId, schema.visibilityGrants.squadId],
    set: { expiresAt: input.expiresAt, grantedById: input.grantedById },
  }).returning();

  return grant;
}

export async function revokeVisibility(granteeUserId: string, squadId: string) {
  await db.delete(schema.visibilityGrants)
    .where(and(
      eq(schema.visibilityGrants.granteeUserId, granteeUserId),
      eq(schema.visibilityGrants.squadId, squadId)
    ));
}

export async function getVisibilityGrants(userId: string) {
  return db.query.visibilityGrants.findMany({
    where: and(
      eq(schema.visibilityGrants.granteeUserId, userId),
      or(
        isNull(schema.visibilityGrants.expiresAt),
        gt(schema.visibilityGrants.expiresAt, new Date())
      )
    ),
  });
}

export async function loadUserContext(userId: string, orgId: string): Promise<UserContext> {
  // Get project memberships
  const projectMemberships = await db.query.projectMembers.findMany({
    where: eq(schema.projectMembers.userId, userId),
  });

  // Get squad memberships with lead status
  const squadMemberships = await db.query.squadMembers.findMany({
    where: eq(schema.squadMembers.userId, userId),
    with: { squad: true },
  });

  // Get visibility grants (non-expired)
  const grants = await getVisibilityGrants(userId);

  // Check if user is restricted (future: from user_settings table)
  // For now, default to NOT restricted (per CONTEXT decision)
  const restrictedToSquad = false;

  return {
    id: userId,
    orgId,
    projectRoles: projectMemberships.map(pm => ({
      projectId: pm.projectId,
      role: pm.role,
    })),
    squadMemberships: squadMemberships.map(sm => ({
      squadId: sm.squadId,
      isLead: sm.squad.leadUserId === userId,
    })),
    visibilityGrants: grants.map(g => ({ squadId: g.squadId })),
    restrictedToSquad,
  };
}

export function computeVisibleSquads(userContext: UserContext): string[] {
  // Admin/PM see all - handled at query level
  if (userContext.projectRoles.some(pr => ['admin', 'pm'].includes(pr.role))) {
    return []; // Empty means "all" for admin/PM
  }

  if (!userContext.restrictedToSquad) {
    return []; // Not restricted, sees all in project
  }

  // Restricted: own squads + granted squads
  const ownSquads = userContext.squadMemberships.map(sm => sm.squadId);
  const grantedSquads = userContext.visibilityGrants.map(vg => vg.squadId);
  return [...new Set([...ownSquads, ...grantedSquads])];
}
```

**visibility.middleware.ts:**
```typescript
import type { Context, Next } from 'hono';
import { defineAbilitiesFor, type AppAbility, type UserContext } from '../../shared/lib/permissions/abilities';
import { loadUserContext, computeVisibleSquads } from './visibility.service';

declare module 'hono' {
  interface ContextVariableMap {
    ability: AppAbility;
    userContext: UserContext;
    visibleSquadIds: string[]; // Empty = all (for admin/PM/unrestricted)
  }
}

export async function visibilityMiddleware(c: Context, next: Next) {
  const user = c.get('user'); // From auth middleware: { sub: userId, org: orgId }

  if (!user) {
    // No auth = no visibility context (let auth middleware handle rejection)
    return next();
  }

  // Load full user context from database
  const userContext = await loadUserContext(user.sub, user.org);
  c.set('userContext', userContext);

  // Build CASL ability
  const ability = defineAbilitiesFor(userContext);
  c.set('ability', ability);

  // Pre-compute visible squad IDs for query filtering
  const visibleSquadIds = computeVisibleSquads(userContext);
  c.set('visibleSquadIds', visibleSquadIds);

  await next();
}
```
  </action>
  <verify>
`bun run typecheck` passes.
Unit test: loadUserContext returns correct structure for a user with project memberships and squad memberships.
  </verify>
  <done>
Visibility service loads user context, computes visible squads, and builds CASL abilities. Middleware sets context variables for downstream routes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create visibility routes and integrate middleware</name>
  <files>
    src/features/visibility/visibility.routes.ts
    src/features/visibility/index.ts
    src/index.ts
  </files>
  <action>
**visibility.routes.ts:**
Create Hono router for visibility management:

POST /api/v1/visibility/grants - Grant cross-squad visibility (auth required, must be admin/pm)
- Body: { granteeUserId: string, squadId: string, expiresAt?: string }
- Call grantVisibility
- Return 201 with grant record

DELETE /api/v1/visibility/grants - Revoke visibility (auth required, must be admin/pm)
- Body: { granteeUserId: string, squadId: string }
- Call revokeVisibility
- Return 204

GET /api/v1/visibility/grants/:userId - Get user's visibility grants (auth required)
- Return array of grants with squad details

GET /api/v1/visibility/context - Get current user's visibility context (auth required)
- Return { isAdmin, isPM, isRestricted, visibleSquadIds, visibleProjectIds }
- Useful for frontend to know what to fetch

Use Zod validation. Auth middleware required on all routes.
Admin/PM check for granting (use CASL ability.can('manage', 'Squad')).

**visibility/index.ts:**
```typescript
export { visibilityRoutes } from './visibility.routes';
export { visibilityMiddleware } from './visibility.middleware';
export * from './visibility.service';
export * from './visibility.types';
```

**src/index.ts:**
- Import visibilityMiddleware
- Apply visibilityMiddleware AFTER authMiddleware on protected routes
- Mount visibility routes

Order of middleware:
1. Request ID
2. Security headers
3. Logger
4. Auth (where required)
5. Visibility (where required, after auth)

Routes structure:
```typescript
// Public routes (no auth, no visibility)
app.route('/api/v1/auth', authRoutes);

// Protected routes (auth + visibility)
const protectedRoutes = new Hono()
  .use('*', authMiddleware)
  .use('*', visibilityMiddleware)
  .route('/invitations', invitationRoutes)
  .route('/invite-links', inviteLinkRoutes)
  .route('/projects', projectRoutes)
  .route('/squads', squadRoutes)
  .route('/roles', roleRoutes)
  .route('/visibility', visibilityRoutes);

app.route('/api/v1', protectedRoutes);
```
  </action>
  <verify>
`bun run typecheck` passes.
`bun run lint` passes.
`bun run dev` starts without errors.

Test with curl:
1. Create user, get JWT
2. GET /api/v1/visibility/context - should show default unrestricted context
3. Create a squad, grant visibility to another user
4. GET /api/v1/visibility/grants/:userId - should show the grant
  </verify>
  <done>
Visibility routes work. Middleware applies to all protected routes. Context endpoint returns current user's visibility state.
  </done>
</task>

</tasks>

<verification>
1. Visibility grants table exists: `psql $DATABASE_URL -c "\dt"` shows visibility_grants
2. TypeScript compiles: `bun run typecheck` passes
3. Linting passes: `bun run lint` has no errors
4. Server starts: `bun run dev` runs without errors
5. Middleware applies: Protected route requests have visibleSquadIds in context
6. Grants work: Creating and revoking grants updates database correctly
7. Context reflects grants: After granting, user's context shows expanded visibility
</verification>

<success_criteria>
- Visibility middleware runs on all protected routes (c.get('userContext') available)
- Admin can grant cross-squad visibility (POST /visibility/grants returns 201)
- Admin can revoke visibility (DELETE /visibility/grants returns 204)
- Context endpoint shows correct visibility state (GET /visibility/context)
- CASL abilities correctly reflect user's role and grants
- Default visibility is project-wide (unrestricted users see all project data)
- Grant expiry is respected (expired grants not included in visibleSquadIds)
</success_criteria>

<output>
After completion, create `.planning/phases/02-team-access/02-03-SUMMARY.md`
</output>
