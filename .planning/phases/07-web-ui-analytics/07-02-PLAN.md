---
phase: 07-web-ui-analytics
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - web/src/app/api/auth/login/route.ts
  - web/src/app/api/auth/logout/route.ts
  - web/src/app/api/auth/refresh/route.ts
  - web/src/app/api/auth/magic-link/route.ts
  - web/src/app/(auth)/login/page.tsx
  - web/src/app/(auth)/login/login-form.tsx
  - web/src/app/(auth)/magic-link/page.tsx
  - web/middleware.ts
  - web/src/lib/api.ts
  - web/src/lib/auth.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can log in with email and password"
    - "User is redirected to login when accessing protected routes unauthenticated"
    - "JWT tokens are stored in HTTP-only cookies"
    - "User can request magic link login"
  artifacts:
    - path: "web/middleware.ts"
      provides: "Route protection before rendering"
      exports: ["middleware", "config"]
    - path: "web/src/app/api/auth/login/route.ts"
      provides: "Login API route that sets cookies"
      exports: ["POST"]
    - path: "web/src/app/(auth)/login/page.tsx"
      provides: "Login page UI"
      min_lines: 10
    - path: "web/src/lib/api.ts"
      provides: "API client for server and client components"
      exports: ["apiClient", "clientApiClient"]
  key_links:
    - from: "web/middleware.ts"
      to: "access_token cookie"
      via: "request.cookies.get"
      pattern: "cookies\\(\\)\\.get\\('access_token'\\)"
    - from: "web/src/app/api/auth/login/route.ts"
      to: "backend /api/v1/auth/login"
      via: "fetch call"
      pattern: "fetch.*auth/login"
    - from: "web/src/app/(auth)/login/login-form.tsx"
      to: "web/src/app/api/auth/login/route.ts"
      via: "form submission"
      pattern: "fetch.*api/auth/login"
---

<objective>
Implement authentication flow with JWT cookies, login/magic-link pages, and route protection middleware.

Purpose: Enable users to authenticate and access protected dashboard routes securely.
Output: Working login flow with password and magic link options, middleware protecting dashboard routes.
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-web-ui-analytics/07-RESEARCH.md
@src/features/auth/auth.routes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth API routes for cookie management</name>
  <files>
    - web/src/app/api/auth/login/route.ts
    - web/src/app/api/auth/logout/route.ts
    - web/src/app/api/auth/refresh/route.ts
    - web/src/app/api/auth/magic-link/request/route.ts
    - web/src/app/api/auth/magic-link/verify/route.ts
  </files>
  <action>
Create Next.js API routes that proxy to the backend and manage HTTP-only cookies.

Create web/src/app/api/auth/login/route.ts:
```typescript
import { cookies } from 'next/headers'
import { NextResponse } from 'next/server'

const API_BASE = process.env.API_URL || 'http://localhost:3000/api/v1'

export async function POST(request: Request) {
  const body = await request.json()

  const response = await fetch(`${API_BASE}/auth/login`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  })

  if (!response.ok) {
    return NextResponse.json(await response.json(), { status: response.status })
  }

  const data = await response.json()
  const cookieStore = await cookies()

  // Set HTTP-only cookies for security
  cookieStore.set('access_token', data.accessToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 60 * 15, // 15 minutes
    path: '/',
  })

  cookieStore.set('refresh_token', data.refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 60 * 60 * 24 * 7, // 7 days
    path: '/',
  })

  return NextResponse.json({ user: data.user })
}
```

Create web/src/app/api/auth/logout/route.ts:
```typescript
import { cookies } from 'next/headers'
import { NextResponse } from 'next/server'

const API_BASE = process.env.API_URL || 'http://localhost:3000/api/v1'

export async function POST() {
  const cookieStore = await cookies()
  const accessToken = cookieStore.get('access_token')?.value

  // Call backend logout if we have a token
  if (accessToken) {
    try {
      await fetch(`${API_BASE}/auth/logout`, {
        method: 'POST',
        headers: { Authorization: `Bearer ${accessToken}` },
      })
    } catch {
      // Ignore errors - we're logging out anyway
    }
  }

  // Clear cookies
  cookieStore.delete('access_token')
  cookieStore.delete('refresh_token')

  return NextResponse.json({ message: 'Logged out' })
}
```

Create web/src/app/api/auth/refresh/route.ts:
```typescript
import { cookies } from 'next/headers'
import { NextResponse } from 'next/server'

const API_BASE = process.env.API_URL || 'http://localhost:3000/api/v1'

export async function POST() {
  const cookieStore = await cookies()
  const refreshToken = cookieStore.get('refresh_token')?.value

  if (!refreshToken) {
    return NextResponse.json({ error: 'No refresh token' }, { status: 401 })
  }

  const response = await fetch(`${API_BASE}/auth/refresh`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ refreshToken }),
  })

  if (!response.ok) {
    // Clear cookies on refresh failure
    cookieStore.delete('access_token')
    cookieStore.delete('refresh_token')
    return NextResponse.json({ error: 'Refresh failed' }, { status: 401 })
  }

  const data = await response.json()

  cookieStore.set('access_token', data.accessToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 60 * 15,
    path: '/',
  })

  cookieStore.set('refresh_token', data.refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 60 * 60 * 24 * 7,
    path: '/',
  })

  return NextResponse.json({ success: true })
}
```

Create magic link routes following similar patterns - request sends email to backend, verify handles callback and sets cookies.
  </action>
  <verify>
```bash
cd /Users/dio/RnD/web
test -f src/app/api/auth/login/route.ts && echo "Login route OK"
test -f src/app/api/auth/logout/route.ts && echo "Logout route OK"
test -f src/app/api/auth/refresh/route.ts && echo "Refresh route OK"
grep -q "cookieStore.set" src/app/api/auth/login/route.ts && echo "Cookie setting OK"
```
  </verify>
  <done>Auth API routes created: login, logout, refresh, magic-link/request, magic-link/verify - all set HTTP-only cookies</done>
</task>

<task type="auto">
  <name>Task 2: Create middleware for route protection</name>
  <files>
    - web/middleware.ts
    - web/src/lib/auth.ts
  </files>
  <action>
Create Next.js middleware that protects dashboard routes and redirects unauthenticated users to login.

Create web/middleware.ts:
```typescript
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

const PUBLIC_PATHS = ['/login', '/magic-link', '/api/auth']

export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl

  // Allow public paths
  if (PUBLIC_PATHS.some(path => pathname.startsWith(path))) {
    return NextResponse.next()
  }

  // Allow static assets and Next.js internals
  if (
    pathname.startsWith('/_next') ||
    pathname.startsWith('/favicon') ||
    pathname.includes('.')
  ) {
    return NextResponse.next()
  }

  // Check for auth cookie
  const token = request.cookies.get('access_token')?.value

  if (!token) {
    const loginUrl = new URL('/login', request.url)
    loginUrl.searchParams.set('callbackUrl', pathname)
    return NextResponse.redirect(loginUrl)
  }

  // Token exists - allow request
  // Note: Full token validation happens on API calls, not in middleware
  // This is intentional - middleware runs at edge and should be fast
  return NextResponse.next()
}

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],
}
```

Create web/src/lib/auth.ts with helper functions:
```typescript
import { cookies } from 'next/headers'

export async function getAccessToken(): Promise<string | undefined> {
  const cookieStore = await cookies()
  return cookieStore.get('access_token')?.value
}

export async function isAuthenticated(): Promise<boolean> {
  const token = await getAccessToken()
  return !!token
}

// For client-side auth state (limited info since cookies are httpOnly)
export function useAuthState() {
  // Client components can't read httpOnly cookies
  // They rely on API calls to determine auth state
  // This hook would check /api/auth/me or similar
}
```
  </action>
  <verify>
```bash
cd /Users/dio/RnD/web
test -f middleware.ts && echo "Middleware OK"
grep -q "PUBLIC_PATHS" middleware.ts && echo "Public paths defined"
grep -q "access_token" middleware.ts && echo "Token check OK"
test -f src/lib/auth.ts && echo "Auth lib OK"
```
  </verify>
  <done>Middleware redirects unauthenticated users to /login, allows public paths, auth helpers created</done>
</task>

<task type="auto">
  <name>Task 3: Create login and magic link pages</name>
  <files>
    - web/src/app/(auth)/login/page.tsx
    - web/src/app/(auth)/login/login-form.tsx
    - web/src/app/(auth)/magic-link/page.tsx
    - web/src/app/(auth)/layout.tsx
    - web/src/lib/api.ts
  </files>
  <action>
Create the authentication pages with forms using shadcn/ui and react-hook-form.

First, install form dependencies:
```bash
cd /Users/dio/RnD/web
npm install react-hook-form @hookform/resolvers zod
```

Create web/src/lib/api.ts for API client:
```typescript
import { cookies } from 'next/headers'

const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000/api/v1'

export class ApiError extends Error {
  constructor(
    public status: number,
    public body: unknown
  ) {
    super(`API Error: ${status}`)
    this.name = 'ApiError'
  }
}

export class AuthError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'AuthError'
  }
}

// For Server Components
export async function apiClient<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  const cookieStore = await cookies()
  const token = cookieStore.get('access_token')?.value

  const response = await fetch(`${API_BASE}${endpoint}`, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...(token && { Authorization: `Bearer ${token}` }),
      ...options.headers,
    },
  })

  if (!response.ok) {
    if (response.status === 401) {
      throw new AuthError('Session expired')
    }
    throw new ApiError(response.status, await response.json())
  }

  return response.json()
}

// For Client Components
export async function clientApiClient<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  const response = await fetch(`${API_BASE}${endpoint}`, {
    ...options,
    credentials: 'include',
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  })

  if (!response.ok) {
    throw new ApiError(response.status, await response.json())
  }

  return response.json()
}
```

Create web/src/app/(auth)/layout.tsx:
```typescript
export default function AuthLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <div className="min-h-screen flex items-center justify-center bg-background">
      <div className="w-full max-w-md p-6">
        {children}
      </div>
    </div>
  )
}
```

Create web/src/app/(auth)/login/page.tsx:
```typescript
import { LoginForm } from './login-form'

export default async function LoginPage({
  searchParams,
}: {
  searchParams: Promise<{ callbackUrl?: string }>
}) {
  const params = await searchParams
  return (
    <div className="space-y-6">
      <div className="space-y-2 text-center">
        <h1 className="text-3xl font-bold">Welcome back</h1>
        <p className="text-muted-foreground">
          Sign in to your BlockBot account
        </p>
      </div>
      <LoginForm callbackUrl={params.callbackUrl} />
    </div>
  )
}
```

Create web/src/app/(auth)/login/login-form.tsx as a client component with:
- Email and password fields using shadcn/ui Input
- Form validation with react-hook-form + zod
- Submit to /api/auth/login
- "Request magic link" alternative button
- Error display for invalid credentials
- Redirect to callbackUrl or / on success

Create web/src/app/(auth)/magic-link/page.tsx that:
- Reads ?token= from URL
- Calls /api/auth/magic-link/verify
- Shows success/error message
- Redirects to dashboard on success
  </action>
  <verify>
```bash
cd /Users/dio/RnD/web
test -f src/app/\\(auth\\)/login/page.tsx && echo "Login page OK"
test -f src/app/\\(auth\\)/login/login-form.tsx && echo "Login form OK"
test -f src/app/\\(auth\\)/magic-link/page.tsx && echo "Magic link page OK"
test -f src/lib/api.ts && echo "API client OK"
grep -q "useForm" src/app/\\(auth\\)/login/login-form.tsx && echo "Form hook OK"
```
  </verify>
  <done>Login page with email/password form, magic link request option, magic link verification page, API client utilities</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `cd /Users/dio/RnD/web && npm run dev` starts without errors
2. Visit http://localhost:3001/ redirects to /login (middleware working)
3. Visit http://localhost:3001/login shows login form
4. TypeScript compiles without errors: `npm run build`
</verification>

<success_criteria>
- Middleware protects all routes except /login, /magic-link, /api/auth/*
- Login page displays with email/password form
- Login form validates input and shows errors
- Successful login sets HTTP-only cookies and redirects
- Magic link request and verification flows work
- API client utilities work for both server and client components
</success_criteria>

<output>
After completion, create `.planning/phases/07-web-ui-analytics/07-02-SUMMARY.md`
</output>
