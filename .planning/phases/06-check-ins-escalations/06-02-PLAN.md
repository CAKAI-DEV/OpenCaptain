---
phase: 06-check-ins-escalations
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/features/recaps/recaps.types.ts
  - src/features/recaps/recaps.service.ts
  - src/features/recaps/recaps.worker.ts
  - src/features/recaps/recaps.routes.ts
  - src/features/recaps/index.ts
  - src/shared/lib/queue/client.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Agent generates daily recap summaries for users"
    - "Agent generates weekly recap summaries for users"
    - "Recaps are tailored to recipient's role (personal for member, squad for lead, project for PM)"
    - "Personal recaps show individual achievements and upcoming work"
    - "Squad recaps show team velocity, blockers, and collaboration patterns"
    - "Project recaps show overall progress, risks, and strategic insights"
  artifacts:
    - path: "src/features/recaps/recaps.service.ts"
      provides: "Role-based recap generation with LLM"
      exports: ["generateRecap", "buildRecapContext"]
    - path: "src/features/recaps/recaps.worker.ts"
      provides: "BullMQ worker for scheduled recaps"
      contains: "recapWorker"
  key_links:
    - from: "src/features/recaps/recaps.service.ts"
      to: "chatCompletionForOrg from ../llm"
      via: "LLM recap generation"
      pattern: "chatCompletionForOrg"
    - from: "src/features/recaps/recaps.service.ts"
      to: "buildVisibilityContext from ../visibility"
      via: "role determination"
      pattern: "buildVisibilityContext"
---

<objective>
Implement role-based recap generation and scheduled delivery.

Purpose: Generate LLM-powered daily and weekly recap summaries tailored to each recipient's role and visibility level (CHCK-05, CHCK-06).
Output: Recap service with role-based context building, LLM generation, and scheduled delivery worker.
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-check-ins-escalations/06-RESEARCH.md

@src/shared/db/schema/user-messaging.ts
@src/shared/db/schema/project-members.ts
@src/features/visibility/visibility.service.ts
@src/features/llm/llm.service.ts
@src/features/metrics/metrics.service.ts
@src/features/messaging/messaging.worker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create recap types and context builder</name>
  <files>src/features/recaps/recaps.types.ts, src/features/recaps/recaps.service.ts</files>
  <action>
1. Create src/features/recaps/recaps.types.ts:
```typescript
import { z } from 'zod';

/**
 * Recap scope determines what data is included
 */
export type RecapScope = 'personal' | 'squad' | 'project';

/**
 * Recap period
 */
export type RecapPeriod = 'daily' | 'weekly';

/**
 * Recap job data for BullMQ
 */
export interface RecapJobData {
  type: 'generate_recap';
  userId: string;
  projectId: string;
  organizationId: string;
  period: RecapPeriod;
}

/**
 * Personal metrics for recap
 */
export interface PersonalMetrics {
  tasksCompleted: number;
  deliverablesCompleted: number;
  tasksInProgress: number;
  blockers: number;
}

/**
 * Squad metrics for recap
 */
export interface SquadMetrics {
  totalCompleted: number;
  byPerson: Array<{ name: string; completed: number }>;
  activeBlockers: number;
  velocity: number; // items per day
}

/**
 * Project metrics for recap
 */
export interface ProjectMetrics {
  totalCompleted: number;
  bySquad: Array<{ name: string; completed: number }>;
  byDay: Array<{ date: string; count: number }>;
  criticalBlockers: number;
  atRiskDeadlines: number;
}

/**
 * Context for recap generation
 */
export interface RecapContext {
  scope: RecapScope;
  period: RecapPeriod;
  userName: string;
  projectName: string;
  metrics: PersonalMetrics | SquadMetrics | ProjectMetrics;
  blockers: Array<{ title: string; reportedAt: Date; status: string }>;
  upcomingDeadlines: Array<{ title: string; dueDate: Date; type: 'task' | 'deliverable' }>;
  recentActivity: Array<{ description: string; timestamp: Date }>;
}

/**
 * Generate recap request schema
 */
export const generateRecapSchema = z.object({
  projectId: z.string().uuid(),
  period: z.enum(['daily', 'weekly']),
});

export type GenerateRecapInput = z.infer<typeof generateRecapSchema>;
```

2. Create src/features/recaps/recaps.service.ts:
```typescript
import { and, eq, gte, lte, sql, desc } from 'drizzle-orm';
import dayjs from 'dayjs';
import { db, schema } from '../../shared/db';
import { logger } from '../../shared/lib/logger';
import { chatCompletionForOrg } from '../llm/llm.service';
import { buildVisibilityContext } from '../visibility/visibility.service';
import type {
  RecapScope,
  RecapPeriod,
  RecapContext,
  PersonalMetrics,
  SquadMetrics,
  ProjectMetrics,
} from './recaps.types';

/**
 * System prompt for recap generation
 */
const RECAP_SYSTEM_PROMPT = `You are a project management assistant generating recap summaries.
Be concise but highlight important patterns. Use bullet points.
Keep the tone professional but friendly.

For personal recaps: focus on individual achievements, progress, and upcoming priorities.
For squad recaps: focus on team velocity, blockers affecting the team, and collaboration patterns.
For project recaps: focus on overall progress toward goals, risks, and strategic insights.

Do not make up information. Only summarize what is provided in the context.
Keep recaps under 300 words.`;

/**
 * Determine recap scope based on user's role
 */
export async function determineRecapScope(
  userId: string,
  projectId: string,
  organizationId: string
): Promise<RecapScope> {
  const visibility = await buildVisibilityContext(userId, organizationId);

  // Admin or PM sees project-wide
  if (visibility.isAdmin || visibility.isPM) {
    return 'project';
  }

  // Check if user is a squad lead
  const membership = await db.query.projectMembers.findFirst({
    where: and(
      eq(schema.projectMembers.userId, userId),
      eq(schema.projectMembers.projectId, projectId)
    ),
    columns: { role: true },
  });

  if (membership?.role === 'squad_lead') {
    return 'squad';
  }

  return 'personal';
}

/**
 * Get date range for period
 */
function getPeriodRange(period: RecapPeriod): { start: Date; end: Date } {
  const now = dayjs();

  if (period === 'daily') {
    return {
      start: now.startOf('day').toDate(),
      end: now.endOf('day').toDate(),
    };
  }

  // Weekly: last 7 days
  return {
    start: now.subtract(7, 'day').startOf('day').toDate(),
    end: now.endOf('day').toDate(),
  };
}

/**
 * Build personal metrics
 */
async function buildPersonalMetrics(
  userId: string,
  projectId: string,
  range: { start: Date; end: Date }
): Promise<PersonalMetrics> {
  // Tasks completed
  const [tasksCompleted] = await db
    .select({ count: sql<number>`count(*)` })
    .from(schema.tasks)
    .where(and(
      eq(schema.tasks.assigneeId, userId),
      eq(schema.tasks.projectId, projectId),
      eq(schema.tasks.status, 'done'),
      gte(schema.tasks.completedAt, range.start),
      lte(schema.tasks.completedAt, range.end)
    ));

  // Deliverables completed (using final status)
  const [deliverablesCompleted] = await db
    .select({ count: sql<number>`count(*)` })
    .from(schema.deliverables)
    .where(and(
      eq(schema.deliverables.assigneeId, userId),
      eq(schema.deliverables.projectId, projectId),
      gte(schema.deliverables.completedAt, range.start),
      lte(schema.deliverables.completedAt, range.end)
    ));

  // Tasks in progress
  const [tasksInProgress] = await db
    .select({ count: sql<number>`count(*)` })
    .from(schema.tasks)
    .where(and(
      eq(schema.tasks.assigneeId, userId),
      eq(schema.tasks.projectId, projectId),
      eq(schema.tasks.status, 'in_progress')
    ));

  return {
    tasksCompleted: Number(tasksCompleted?.count ?? 0),
    deliverablesCompleted: Number(deliverablesCompleted?.count ?? 0),
    tasksInProgress: Number(tasksInProgress?.count ?? 0),
    blockers: 0, // Will be populated from blockers table in plan 06-03
  };
}

/**
 * Build squad metrics
 */
async function buildSquadMetrics(
  userId: string,
  projectId: string,
  range: { start: Date; end: Date }
): Promise<SquadMetrics> {
  // Get user's squad
  const squadMember = await db.query.squadMembers.findFirst({
    where: eq(schema.squadMembers.userId, userId),
    with: { squad: true },
  });

  if (!squadMember) {
    return { totalCompleted: 0, byPerson: [], activeBlockers: 0, velocity: 0 };
  }

  // Get squad members
  const members = await db.query.squadMembers.findMany({
    where: eq(schema.squadMembers.squadId, squadMember.squadId),
    with: { user: { columns: { email: true } } },
  });

  const memberIds = members.map((m) => m.userId);

  // Total completed (tasks + deliverables)
  const completedByPerson: Array<{ name: string; completed: number }> = [];
  let totalCompleted = 0;

  for (const member of members) {
    const [tasks] = await db
      .select({ count: sql<number>`count(*)` })
      .from(schema.tasks)
      .where(and(
        eq(schema.tasks.assigneeId, member.userId),
        eq(schema.tasks.projectId, projectId),
        eq(schema.tasks.status, 'done'),
        gte(schema.tasks.completedAt, range.start),
        lte(schema.tasks.completedAt, range.end)
      ));

    const [deliverables] = await db
      .select({ count: sql<number>`count(*)` })
      .from(schema.deliverables)
      .where(and(
        eq(schema.deliverables.assigneeId, member.userId),
        eq(schema.deliverables.projectId, projectId),
        gte(schema.deliverables.completedAt, range.start),
        lte(schema.deliverables.completedAt, range.end)
      ));

    const completed = Number(tasks?.count ?? 0) + Number(deliverables?.count ?? 0);
    totalCompleted += completed;

    completedByPerson.push({
      name: member.user?.email?.split('@')[0] ?? 'Unknown',
      completed,
    });
  }

  const days = dayjs(range.end).diff(dayjs(range.start), 'day') || 1;

  return {
    totalCompleted,
    byPerson: completedByPerson,
    activeBlockers: 0, // Will be populated from blockers table
    velocity: Math.round((totalCompleted / days) * 10) / 10,
  };
}

/**
 * Build project metrics
 */
async function buildProjectMetrics(
  projectId: string,
  range: { start: Date; end: Date }
): Promise<ProjectMetrics> {
  // Get all squads in project
  const squads = await db.query.squads.findMany({
    where: eq(schema.squads.projectId, projectId),
    columns: { id: true, name: true },
  });

  const bySquad: Array<{ name: string; completed: number }> = [];
  let totalCompleted = 0;

  for (const squad of squads) {
    const squadMembers = await db.query.squadMembers.findMany({
      where: eq(schema.squadMembers.squadId, squad.id),
      columns: { userId: true },
    });

    const memberIds = squadMembers.map((m) => m.userId);
    let squadCompleted = 0;

    if (memberIds.length > 0) {
      // Count completed tasks
      const tasksResult = await db.execute<{ count: number }>(sql`
        SELECT COUNT(*) as count FROM tasks
        WHERE assignee_id = ANY(${memberIds})
        AND project_id = ${projectId}
        AND status = 'done'
        AND completed_at >= ${range.start}
        AND completed_at <= ${range.end}
      `);
      squadCompleted += Number((tasksResult as unknown as Array<{ count: number }>)[0]?.count ?? 0);

      // Count completed deliverables
      const deliverablesResult = await db.execute<{ count: number }>(sql`
        SELECT COUNT(*) as count FROM deliverables
        WHERE assignee_id = ANY(${memberIds})
        AND project_id = ${projectId}
        AND completed_at >= ${range.start}
        AND completed_at <= ${range.end}
      `);
      squadCompleted += Number((deliverablesResult as unknown as Array<{ count: number }>)[0]?.count ?? 0);
    }

    totalCompleted += squadCompleted;
    bySquad.push({ name: squad.name, completed: squadCompleted });
  }

  // Daily breakdown
  const days = dayjs(range.end).diff(dayjs(range.start), 'day') + 1;
  const byDay: Array<{ date: string; count: number }> = [];

  for (let i = 0; i < Math.min(days, 7); i++) {
    const dayStart = dayjs(range.end).subtract(i, 'day').startOf('day').toDate();
    const dayEnd = dayjs(range.end).subtract(i, 'day').endOf('day').toDate();

    const [dayTasks] = await db
      .select({ count: sql<number>`count(*)` })
      .from(schema.tasks)
      .where(and(
        eq(schema.tasks.projectId, projectId),
        eq(schema.tasks.status, 'done'),
        gte(schema.tasks.completedAt, dayStart),
        lte(schema.tasks.completedAt, dayEnd)
      ));

    byDay.push({
      date: dayjs(dayStart).format('YYYY-MM-DD'),
      count: Number(dayTasks?.count ?? 0),
    });
  }

  // At-risk deadlines (due within 3 days, not done)
  const riskDate = dayjs().add(3, 'day').toDate();
  const [atRisk] = await db
    .select({ count: sql<number>`count(*)` })
    .from(schema.deliverables)
    .where(and(
      eq(schema.deliverables.projectId, projectId),
      lte(schema.deliverables.dueDate, riskDate),
      sql`${schema.deliverables.completedAt} IS NULL`
    ));

  return {
    totalCompleted,
    bySquad,
    byDay: byDay.reverse(),
    criticalBlockers: 0, // Will be populated from blockers
    atRiskDeadlines: Number(atRisk?.count ?? 0),
  };
}

/**
 * Get upcoming deadlines
 */
async function getUpcomingDeadlines(
  userId: string,
  projectId: string,
  scope: RecapScope,
  limit = 5
): Promise<Array<{ title: string; dueDate: Date; type: 'task' | 'deliverable' }>> {
  const now = new Date();
  const result: Array<{ title: string; dueDate: Date; type: 'task' | 'deliverable' }> = [];

  // Get tasks
  const taskConditions = [
    eq(schema.tasks.projectId, projectId),
    gte(schema.tasks.dueDate, now),
    sql`${schema.tasks.status} != 'done'`,
  ];

  if (scope === 'personal') {
    taskConditions.push(eq(schema.tasks.assigneeId, userId));
  }

  const tasks = await db.query.tasks.findMany({
    where: and(...taskConditions),
    columns: { title: true, dueDate: true },
    orderBy: (t, { asc }) => [asc(t.dueDate)],
    limit,
  });

  for (const task of tasks) {
    if (task.dueDate) {
      result.push({ title: task.title, dueDate: task.dueDate, type: 'task' });
    }
  }

  // Get deliverables
  const deliverableConditions = [
    eq(schema.deliverables.projectId, projectId),
    gte(schema.deliverables.dueDate, now),
    sql`${schema.deliverables.completedAt} IS NULL`,
  ];

  if (scope === 'personal') {
    deliverableConditions.push(eq(schema.deliverables.assigneeId, userId));
  }

  const deliverables = await db.query.deliverables.findMany({
    where: and(...deliverableConditions),
    columns: { title: true, dueDate: true },
    orderBy: (d, { asc }) => [asc(d.dueDate)],
    limit,
  });

  for (const deliverable of deliverables) {
    if (deliverable.dueDate) {
      result.push({ title: deliverable.title, dueDate: deliverable.dueDate, type: 'deliverable' });
    }
  }

  // Sort by due date and take top N
  return result
    .sort((a, b) => a.dueDate.getTime() - b.dueDate.getTime())
    .slice(0, limit);
}

/**
 * Build recap context based on scope
 */
export async function buildRecapContext(
  userId: string,
  projectId: string,
  organizationId: string,
  period: RecapPeriod
): Promise<RecapContext> {
  const scope = await determineRecapScope(userId, projectId, organizationId);
  const range = getPeriodRange(period);

  // Get user and project names
  const user = await db.query.users.findFirst({
    where: eq(schema.users.id, userId),
    columns: { email: true },
  });
  const project = await db.query.projects.findFirst({
    where: eq(schema.projects.id, projectId),
    columns: { name: true },
  });

  // Build metrics based on scope
  let metrics: PersonalMetrics | SquadMetrics | ProjectMetrics;

  switch (scope) {
    case 'personal':
      metrics = await buildPersonalMetrics(userId, projectId, range);
      break;
    case 'squad':
      metrics = await buildSquadMetrics(userId, projectId, range);
      break;
    case 'project':
      metrics = await buildProjectMetrics(projectId, range);
      break;
  }

  const upcomingDeadlines = await getUpcomingDeadlines(userId, projectId, scope);

  return {
    scope,
    period,
    userName: user?.email?.split('@')[0] ?? 'User',
    projectName: project?.name ?? 'Project',
    metrics,
    blockers: [], // Will be populated from blockers table in 06-03
    upcomingDeadlines,
    recentActivity: [], // Could be populated from activity feed
  };
}

/**
 * Build LLM prompt based on scope
 */
function buildRecapPrompt(context: RecapContext): string {
  const periodLabel = context.period === 'daily' ? 'today' : 'this week';

  switch (context.scope) {
    case 'personal': {
      const metrics = context.metrics as PersonalMetrics;
      return `Generate a ${context.period} personal recap for ${context.userName} on project "${context.projectName}" for ${periodLabel}:

Tasks completed: ${metrics.tasksCompleted}
Deliverables completed: ${metrics.deliverablesCompleted}
Tasks in progress: ${metrics.tasksInProgress}
Active blockers: ${metrics.blockers}

Upcoming deadlines:
${context.upcomingDeadlines.map((d) => `- ${d.title} (${d.type}) due ${dayjs(d.dueDate).format('MMM D')}`).join('\n') || 'None'}

Generate a brief, encouraging summary (3-5 bullet points) focusing on achievements and upcoming priorities.`;
    }

    case 'squad': {
      const metrics = context.metrics as SquadMetrics;
      return `Generate a ${context.period} squad recap for ${context.userName}'s team on project "${context.projectName}" for ${periodLabel}:

Total team output: ${metrics.totalCompleted} items completed
Team velocity: ${metrics.velocity} items/day
Active blockers: ${metrics.activeBlockers}

By team member:
${metrics.byPerson.map((p) => `- ${p.name}: ${p.completed} completed`).join('\n')}

Upcoming deadlines:
${context.upcomingDeadlines.map((d) => `- ${d.title} due ${dayjs(d.dueDate).format('MMM D')}`).join('\n') || 'None'}

Generate a team-focused summary (4-6 bullet points) highlighting patterns, any blockers needing attention, and team collaboration.`;
    }

    case 'project': {
      const metrics = context.metrics as ProjectMetrics;
      return `Generate a ${context.period} project recap for "${context.projectName}" for ${periodLabel}:

Total output: ${metrics.totalCompleted} items completed
At-risk deadlines: ${metrics.atRiskDeadlines}
Critical blockers: ${metrics.criticalBlockers}

By squad:
${metrics.bySquad.map((s) => `- ${s.name}: ${s.completed} completed`).join('\n')}

Daily trend:
${metrics.byDay.map((d) => `- ${d.date}: ${d.count}`).join('\n')}

Generate a strategic summary (5-7 bullet points) with overall progress, risks requiring attention, and recommendations.`;
    }
  }
}

/**
 * Generate recap using LLM
 */
export async function generateRecap(
  userId: string,
  projectId: string,
  organizationId: string,
  period: RecapPeriod
): Promise<string> {
  const context = await buildRecapContext(userId, projectId, organizationId, period);

  logger.info({ userId, projectId, scope: context.scope, period }, 'Generating recap');

  const prompt = buildRecapPrompt(context);

  try {
    const result = await chatCompletionForOrg(organizationId, [
      { role: 'system', content: RECAP_SYSTEM_PROMPT },
      { role: 'user', content: prompt },
    ]);

    // Add header with scope info
    const scopeLabel = context.scope === 'personal' ? 'Personal' :
                       context.scope === 'squad' ? 'Squad' : 'Project';
    const periodLabel = period === 'daily' ? 'Daily' : 'Weekly';

    return `${periodLabel} ${scopeLabel} Recap - ${context.projectName}\n\n${result.content}`;
  } catch (err) {
    logger.error({ err, userId, projectId }, 'Failed to generate recap');

    // Fallback to simple metrics summary
    return buildFallbackRecap(context);
  }
}

/**
 * Fallback recap when LLM fails
 */
function buildFallbackRecap(context: RecapContext): string {
  const periodLabel = context.period === 'daily' ? 'Daily' : 'Weekly';
  const lines = [`${periodLabel} Recap - ${context.projectName}`, ''];

  if (context.scope === 'personal') {
    const metrics = context.metrics as PersonalMetrics;
    lines.push(`Tasks completed: ${metrics.tasksCompleted}`);
    lines.push(`Deliverables completed: ${metrics.deliverablesCompleted}`);
    lines.push(`In progress: ${metrics.tasksInProgress}`);
  } else if (context.scope === 'squad') {
    const metrics = context.metrics as SquadMetrics;
    lines.push(`Team output: ${metrics.totalCompleted} items`);
    lines.push(`Velocity: ${metrics.velocity} items/day`);
  } else {
    const metrics = context.metrics as ProjectMetrics;
    lines.push(`Total output: ${metrics.totalCompleted} items`);
    lines.push(`At-risk deadlines: ${metrics.atRiskDeadlines}`);
  }

  if (context.upcomingDeadlines.length > 0) {
    lines.push('', 'Upcoming:');
    for (const d of context.upcomingDeadlines.slice(0, 3)) {
      lines.push(`- ${d.title} (${dayjs(d.dueDate).format('MMM D')})`);
    }
  }

  return lines.join('\n');
}
```
  </action>
  <verify>bun run typecheck passes</verify>
  <done>Recap service with role-based context building and LLM generation implemented</done>
</task>

<task type="auto">
  <name>Task 2: Create recap worker and routes</name>
  <files>src/features/recaps/recaps.worker.ts, src/features/recaps/recaps.routes.ts, src/features/recaps/index.ts, src/shared/lib/queue/client.ts, src/index.ts</files>
  <action>
1. Add recap queue to src/shared/lib/queue/client.ts:
```typescript
export const recapQueue = new Queue('recaps', {
  connection: getQueueConnection(),
});

// Update closeQueueConnections to include:
await recapQueue.close();
```

2. Create src/features/recaps/recaps.worker.ts:
```typescript
import { Queue, Worker } from 'bullmq';
import { eq, and } from 'drizzle-orm';
import { db, schema } from '../../shared/db';
import { logger } from '../../shared/lib/logger';
import { getQueueConnection, recapQueue } from '../../shared/lib/queue/client';
import { registerWorker } from '../../shared/lib/queue/workers';
import { sendTelegramMessage } from '../telegram';
import { sendWhatsAppMessage } from '../whatsapp/whatsapp.client';
import { generateRecap } from './recaps.service';
import type { RecapJobData, RecapPeriod } from './recaps.types';

/**
 * Deliver recap message to user
 */
async function deliverRecapMessage(userId: string, message: string): Promise<boolean> {
  const userMessaging = await db.query.userMessaging.findFirst({
    where: eq(schema.userMessaging.userId, userId),
  });

  if (!userMessaging?.messagingEnabled) {
    logger.info({ userId }, 'Messaging disabled, skipping recap delivery');
    return false;
  }

  // Check preference based on period (encoded in message)
  const isWeekly = message.includes('Weekly');
  if (isWeekly && !userMessaging.weeklyRecapEnabled) {
    logger.info({ userId }, 'Weekly recap disabled, skipping');
    return false;
  }
  if (!isWeekly && !userMessaging.dailyCheckinEnabled) {
    // Use dailyCheckinEnabled for daily recaps too
    logger.info({ userId }, 'Daily recap disabled, skipping');
    return false;
  }

  let delivered = false;

  // Deliver via Telegram
  if (userMessaging.telegramChatId && userMessaging.telegramVerified) {
    try {
      await sendTelegramMessage(userMessaging.telegramChatId, message);
      logger.info({ userId, platform: 'telegram' }, 'Recap delivered');
      delivered = true;
    } catch (err) {
      logger.error({ err, userId }, 'Failed to deliver recap via Telegram');
    }
  }

  // Deliver via WhatsApp
  if (userMessaging.whatsappPhone && userMessaging.whatsappVerified) {
    try {
      await sendWhatsAppMessage(userMessaging.whatsappPhone, message);
      logger.info({ userId, platform: 'whatsapp' }, 'Recap delivered');
      delivered = true;
    } catch (err) {
      logger.error({ err, userId }, 'Failed to deliver recap via WhatsApp');
    }
  }

  return delivered;
}

/**
 * Recap worker - generates and delivers scheduled recaps
 */
export const recapWorker = new Worker<RecapJobData>(
  'recaps',
  async (job) => {
    const { userId, projectId, organizationId, period } = job.data;
    logger.info({ jobId: job.id, userId, projectId, period }, 'Processing recap job');

    try {
      // Generate role-appropriate recap
      const recap = await generateRecap(userId, projectId, organizationId, period);

      // Deliver to user
      await deliverRecapMessage(userId, recap);
    } catch (err) {
      logger.error({ err, userId, projectId }, 'Failed to generate/deliver recap');
      throw err; // Allow retry
    }
  },
  {
    connection: getQueueConnection(),
    concurrency: 5,
  }
);

// Register for graceful shutdown
registerWorker(recapWorker);

/**
 * Schedule recaps for all users in a project
 */
export async function scheduleProjectRecaps(
  projectId: string,
  organizationId: string,
  period: RecapPeriod
): Promise<void> {
  // Get project members with messaging enabled
  const members = await db.query.projectMembers.findMany({
    where: eq(schema.projectMembers.projectId, projectId),
    columns: { userId: true },
  });

  const messagingPrefs = await db.query.userMessaging.findMany({
    where: eq(schema.userMessaging.messagingEnabled, true),
  });
  const enabledUserIds = new Set(messagingPrefs.map((p) => p.userId));

  const eligibleMembers = members.filter((m) => enabledUserIds.has(m.userId));

  logger.info({ projectId, period, count: eligibleMembers.length }, 'Scheduling recaps');

  for (const member of eligibleMembers) {
    await queueRecap(member.userId, projectId, organizationId, period);
  }
}

/**
 * Queue a single recap for delivery
 */
export async function queueRecap(
  userId: string,
  projectId: string,
  organizationId: string,
  period: RecapPeriod
): Promise<void> {
  await recapQueue.add(
    `recap-${userId}-${projectId}-${period}`,
    {
      type: 'generate_recap',
      userId,
      projectId,
      organizationId,
      period,
    },
    {
      attempts: 3,
      backoff: { type: 'exponential', delay: 2000 },
    }
  );
}

/**
 * Schedule recurring recaps for a project
 */
export async function scheduleRecurringRecaps(
  projectId: string,
  organizationId: string
): Promise<void> {
  const members = await db.query.projectMembers.findMany({
    where: eq(schema.projectMembers.projectId, projectId),
    columns: { userId: true },
  });

  for (const member of members) {
    // Daily recap at 6 PM
    await recapQueue.add(
      `daily-recap-${member.userId}-${projectId}`,
      {
        type: 'generate_recap',
        userId: member.userId,
        projectId,
        organizationId,
        period: 'daily' as RecapPeriod,
      },
      {
        repeat: { pattern: '0 18 * * *' }, // 6 PM daily
        jobId: `daily-recap-${member.userId}-${projectId}`,
      }
    );

    // Weekly recap on Friday 5 PM
    await recapQueue.add(
      `weekly-recap-${member.userId}-${projectId}`,
      {
        type: 'generate_recap',
        userId: member.userId,
        projectId,
        organizationId,
        period: 'weekly' as RecapPeriod,
      },
      {
        repeat: { pattern: '0 17 * * 5' }, // 5 PM Friday
        jobId: `weekly-recap-${member.userId}-${projectId}`,
      }
    );
  }

  logger.info({ projectId, members: members.length }, 'Scheduled recurring recaps');
}

export { recapQueue };
```

3. Create src/features/recaps/recaps.routes.ts:
```typescript
import { Hono } from 'hono';
import { zValidator } from '@hono/zod-validator';
import { authMiddleware, type AuthContext } from '../auth/auth.middleware';
import { visibilityMiddleware, type VisibilityContext } from '../visibility/visibility.middleware';
import { ApiError } from '../../shared/types';
import { db, schema } from '../../shared/db';
import { eq } from 'drizzle-orm';
import { generateRecap, buildRecapContext } from './recaps.service';
import { queueRecap, scheduleRecurringRecaps } from './recaps.worker';
import { generateRecapSchema } from './recaps.types';

type RecapContext = AuthContext & VisibilityContext;
const app = new Hono<RecapContext>();

app.use('*', authMiddleware);
app.use('*', visibilityMiddleware);

// Generate recap on-demand
app.post(
  '/generate',
  zValidator('json', generateRecapSchema),
  async (c) => {
    const userId = c.get('userId');
    const organizationId = c.get('organizationId');
    const { projectId, period } = c.req.valid('json');

    // Verify project access
    const visibleProjectIds = c.get('visibleProjectIds');
    if (!visibleProjectIds.includes(projectId)) {
      throw new ApiError(403, 'Access denied to this project');
    }

    const recap = await generateRecap(userId, projectId, organizationId, period);
    return c.json({ data: { recap } });
  }
);

// Get recap preview (context without LLM generation)
app.post(
  '/preview',
  zValidator('json', generateRecapSchema),
  async (c) => {
    const userId = c.get('userId');
    const organizationId = c.get('organizationId');
    const { projectId, period } = c.req.valid('json');

    const visibleProjectIds = c.get('visibleProjectIds');
    if (!visibleProjectIds.includes(projectId)) {
      throw new ApiError(403, 'Access denied to this project');
    }

    const context = await buildRecapContext(userId, projectId, organizationId, period);
    return c.json({ data: context });
  }
);

// Queue recap for delivery (admin/pm only)
app.post(
  '/queue',
  zValidator('json', generateRecapSchema),
  async (c) => {
    const userId = c.get('userId');
    const organizationId = c.get('organizationId');
    const { projectId, period } = c.req.valid('json');

    const visibleProjectIds = c.get('visibleProjectIds');
    if (!visibleProjectIds.includes(projectId)) {
      throw new ApiError(403, 'Access denied to this project');
    }

    await queueRecap(userId, projectId, organizationId, period);
    return c.json({ data: { queued: true } });
  }
);

// Enable recurring recaps for a project (admin only)
app.post(
  '/projects/:projectId/enable-recurring',
  async (c) => {
    const projectId = c.req.param('projectId');
    const organizationId = c.get('organizationId');

    const visibleProjectIds = c.get('visibleProjectIds');
    if (!visibleProjectIds.includes(projectId)) {
      throw new ApiError(403, 'Access denied to this project');
    }

    // Get project's organization
    const project = await db.query.projects.findFirst({
      where: eq(schema.projects.id, projectId),
      columns: { organizationId: true },
    });

    if (!project) {
      throw new ApiError(404, 'Project not found');
    }

    await scheduleRecurringRecaps(projectId, project.organizationId);
    return c.json({ data: { enabled: true } });
  }
);

export default app;
```

4. Create src/features/recaps/index.ts:
```typescript
export { default as recapsRoutes } from './recaps.routes';
export { recapWorker, recapQueue, queueRecap, scheduleProjectRecaps, scheduleRecurringRecaps } from './recaps.worker';
export {
  generateRecap,
  buildRecapContext,
  determineRecapScope,
} from './recaps.service';
export type { RecapScope, RecapPeriod, RecapContext, RecapJobData } from './recaps.types';
```

5. Register routes and import worker in src/index.ts:
```typescript
// Add imports
import { recapsRoutes } from './features/recaps';
import './features/recaps/recaps.worker';

// Add route
app.route('/api/v1/recaps', recapsRoutes);
```
  </action>
  <verify>bun run typecheck passes, bun run lint passes</verify>
  <done>Recap worker generates and delivers role-tailored recaps on schedule</done>
</task>

</tasks>

<verification>
- [ ] POST /api/v1/recaps/generate returns LLM-generated recap
- [ ] POST /api/v1/recaps/preview returns recap context without LLM
- [ ] POST /api/v1/recaps/queue queues recap for delivery
- [ ] POST /api/v1/recaps/projects/:id/enable-recurring schedules daily/weekly recaps
- [ ] Personal recap shows individual metrics for members
- [ ] Squad recap shows team metrics for squad leads
- [ ] Project recap shows project-wide metrics for PM/admin
- [ ] Recaps delivered via Telegram and WhatsApp
- [ ] bun run typecheck and bun run lint pass
</verification>

<success_criteria>
- Daily and weekly recaps generated for project users
- Recaps tailored to role: personal (member), squad (lead), project (PM/admin)
- Personal recaps focus on individual achievements and upcoming work
- Squad recaps include team velocity, member breakdown, and blockers
- Project recaps include strategic insights, squad comparison, and risks
- LLM-powered natural language summaries with fallback to metrics
</success_criteria>

<output>
After completion, create `.planning/phases/06-check-ins-escalations/06-02-SUMMARY.md`
</output>
