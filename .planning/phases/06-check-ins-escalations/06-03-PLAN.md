---
phase: 06-check-ins-escalations
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - src/shared/db/schema/escalation-blocks.ts
  - src/shared/db/schema/blockers.ts
  - src/shared/db/schema/index.ts
  - src/shared/db/migrations/0014_escalations.sql
  - src/features/escalations/escalations.types.ts
  - src/features/escalations/escalations.service.ts
  - src/features/escalations/escalations.worker.ts
  - src/features/escalations/deadline-monitor.worker.ts
  - src/features/escalations/escalations.routes.ts
  - src/features/escalations/index.ts
  - src/features/messaging/messaging.intents.ts
  - src/features/messaging/messaging.service.ts
  - src/shared/lib/queue/client.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Admin can create escalation blocks with trigger type (blocker, deadline risk, output threshold)"
    - "Escalation blocks support time-windowed routing chains (e.g., 4hr to squad lead, 24hr to PM)"
    - "User can report blocker via messaging channel ('I'm blocked on X')"
    - "Squad lead can mark blocker as resolved"
    - "Deadline risk alerts sent when deliverable due soon without progress"
    - "Output threshold warnings sent when user output drops below configured level"
    - "Escalations follow reportsToUserId chain for routing"
  artifacts:
    - path: "src/shared/db/schema/escalation-blocks.ts"
      provides: "Escalation configuration schema"
      contains: "escalationBlocks"
    - path: "src/shared/db/schema/blockers.ts"
      provides: "Blocker tracking schema"
      contains: "blockers"
    - path: "src/features/escalations/escalations.worker.ts"
      provides: "Time-windowed escalation processor"
      contains: "escalationWorker"
    - path: "src/features/escalations/deadline-monitor.worker.ts"
      provides: "Proactive deadline and output monitoring"
      contains: "deadlineMonitorWorker"
  key_links:
    - from: "src/features/escalations/escalations.service.ts"
      to: "escalationQueue"
      via: "delayed job scheduling"
      pattern: "escalationQueue\\.add.*delay"
    - from: "src/features/messaging/messaging.service.ts"
      to: "reportBlocker from ../escalations"
      via: "blocker intent handling"
      pattern: "import.*reportBlocker"
---

<objective>
Implement escalation blocks with configurable triggers and time-windowed routing chains.

Purpose: Enable admins to configure automatic escalation of blockers, deadline risks, and output drops through time-based notification chains (ESCL-01 through ESCL-07).
Output: Escalation schema, blocker tracking, delayed job-based escalation chains, deadline monitoring, and messaging integration.
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-check-ins-escalations/06-RESEARCH.md

@src/shared/db/schema/project-members.ts
@src/shared/db/schema/user-messaging.ts
@src/shared/lib/queue/client.ts
@src/features/messaging/messaging.intents.ts
@src/features/messaging/messaging.service.ts
@src/features/notifications/notifications.worker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create escalation and blocker schemas with migration</name>
  <files>src/shared/db/schema/escalation-blocks.ts, src/shared/db/schema/blockers.ts, src/shared/db/schema/index.ts, src/shared/db/migrations/0014_escalations.sql</files>
  <action>
1. Create src/shared/db/schema/escalation-blocks.ts:
```typescript
import { relations } from 'drizzle-orm';
import { boolean, index, jsonb, pgTable, timestamp, uuid, varchar } from 'drizzle-orm/pg-core';
import { projects } from './projects';
import { users } from './users';

/**
 * Trigger configuration types
 */
export type TriggerConfig =
  | { type: 'blocker_reported' }
  | { type: 'deadline_risk'; daysBeforeDue: number; minProgress: number }
  | { type: 'output_below_threshold'; periodDays: number; minOutput: number };

/**
 * Escalation chain step
 */
export interface EscalationStep {
  delayMinutes: number;    // 0 = immediate, 240 = 4 hours, 1440 = 24 hours
  targetType: 'role' | 'user' | 'reports_to';
  targetRole?: 'squad_lead' | 'pm' | 'admin';  // For role targeting
  targetUserId?: string;    // For specific user targeting
  // 'reports_to' uses the reporter's reportsToUserId chain
}

/**
 * Escalation blocks - admin-configured escalation rules
 */
export const escalationBlocks = pgTable(
  'escalation_blocks',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    projectId: uuid('project_id')
      .notNull()
      .references(() => projects.id, { onDelete: 'cascade' }),
    createdById: uuid('created_by_id')
      .notNull()
      .references(() => users.id),

    name: varchar('name', { length: 255 }).notNull(),
    description: varchar('description', { length: 1000 }),

    // Trigger configuration
    triggerType: varchar('trigger_type', { length: 50 }).notNull(),
      // 'blocker_reported' | 'deadline_risk' | 'output_below_threshold'
    triggerConfig: jsonb('trigger_config').$type<TriggerConfig>().notNull(),

    // Escalation chain (time-windowed routing)
    escalationChain: jsonb('escalation_chain').$type<EscalationStep[]>().notNull(),

    enabled: boolean('enabled').default(true).notNull(),

    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
  },
  (table) => [
    index('escalation_blocks_project_id_idx').on(table.projectId),
    index('escalation_blocks_trigger_type_idx').on(table.triggerType),
    index('escalation_blocks_enabled_idx').on(table.enabled),
  ]
);

export const escalationBlocksRelations = relations(escalationBlocks, ({ one }) => ({
  project: one(projects, {
    fields: [escalationBlocks.projectId],
    references: [projects.id],
  }),
  createdBy: one(users, {
    fields: [escalationBlocks.createdById],
    references: [users.id],
  }),
}));
```

2. Create src/shared/db/schema/blockers.ts:
```typescript
import { relations } from 'drizzle-orm';
import { index, integer, pgTable, text, timestamp, uuid, varchar } from 'drizzle-orm/pg-core';
import { projects } from './projects';
import { users } from './users';

/**
 * Blockers - reported blockers with escalation tracking
 */
export const blockers = pgTable(
  'blockers',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    projectId: uuid('project_id')
      .notNull()
      .references(() => projects.id, { onDelete: 'cascade' }),

    // Who reported the blocker
    reportedById: uuid('reported_by_id')
      .notNull()
      .references(() => users.id),

    // What is blocked (polymorphic)
    targetType: varchar('target_type', { length: 20 }).notNull(), // 'task' | 'deliverable' | 'general'
    targetId: uuid('target_id'), // null for general blockers

    // Blocker details
    title: varchar('title', { length: 500 }).notNull(),
    description: text('description'),

    // State
    status: varchar('status', { length: 20 }).notNull().default('open'),
      // 'open' | 'escalated' | 'resolved'
    resolvedById: uuid('resolved_by_id').references(() => users.id),
    resolvedAt: timestamp('resolved_at', { withTimezone: true }),
    resolutionNotes: text('resolution_notes'),

    // Escalation tracking
    currentEscalationStep: integer('current_escalation_step').default(0).notNull(),
    lastEscalatedAt: timestamp('last_escalated_at', { withTimezone: true }),

    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
  },
  (table) => [
    index('blockers_project_id_idx').on(table.projectId),
    index('blockers_reported_by_id_idx').on(table.reportedById),
    index('blockers_status_idx').on(table.status),
    index('blockers_target_idx').on(table.targetType, table.targetId),
  ]
);

export const blockersRelations = relations(blockers, ({ one }) => ({
  project: one(projects, {
    fields: [blockers.projectId],
    references: [projects.id],
  }),
  reportedBy: one(users, {
    fields: [blockers.reportedById],
    references: [users.id],
    relationName: 'reportedBlockers',
  }),
  resolvedBy: one(users, {
    fields: [blockers.resolvedById],
    references: [users.id],
    relationName: 'resolvedBlockers',
  }),
}));
```

3. Update src/shared/db/schema/index.ts to export new schemas:
```typescript
// Add exports:
export * from './escalation-blocks';
export * from './blockers';
```

4. Create migration src/shared/db/migrations/0014_escalations.sql:
```sql
-- Escalation blocks table
CREATE TABLE IF NOT EXISTS escalation_blocks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
  created_by_id UUID NOT NULL REFERENCES users(id),

  name VARCHAR(255) NOT NULL,
  description VARCHAR(1000),

  trigger_type VARCHAR(50) NOT NULL,
  trigger_config JSONB NOT NULL,

  escalation_chain JSONB NOT NULL,

  enabled BOOLEAN NOT NULL DEFAULT true,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS escalation_blocks_project_id_idx ON escalation_blocks(project_id);
CREATE INDEX IF NOT EXISTS escalation_blocks_trigger_type_idx ON escalation_blocks(trigger_type);
CREATE INDEX IF NOT EXISTS escalation_blocks_enabled_idx ON escalation_blocks(enabled);

-- Blockers table
CREATE TABLE IF NOT EXISTS blockers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,

  reported_by_id UUID NOT NULL REFERENCES users(id),

  target_type VARCHAR(20) NOT NULL,
  target_id UUID,

  title VARCHAR(500) NOT NULL,
  description TEXT,

  status VARCHAR(20) NOT NULL DEFAULT 'open',
  resolved_by_id UUID REFERENCES users(id),
  resolved_at TIMESTAMPTZ,
  resolution_notes TEXT,

  current_escalation_step INTEGER NOT NULL DEFAULT 0,
  last_escalated_at TIMESTAMPTZ,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS blockers_project_id_idx ON blockers(project_id);
CREATE INDEX IF NOT EXISTS blockers_reported_by_id_idx ON blockers(reported_by_id);
CREATE INDEX IF NOT EXISTS blockers_status_idx ON blockers(status);
CREATE INDEX IF NOT EXISTS blockers_target_idx ON blockers(target_type, target_id);
```

5. Update migrations meta/_journal.json to add entry 14.
  </action>
  <verify>bun run db:generate succeeds, bun run typecheck passes</verify>
  <done>Escalation blocks and blockers schema created with migration</done>
</task>

<task type="auto">
  <name>Task 2: Create escalation service and worker</name>
  <files>src/features/escalations/escalations.types.ts, src/features/escalations/escalations.service.ts, src/features/escalations/escalations.worker.ts, src/shared/lib/queue/client.ts</files>
  <action>
1. Add escalation queue to src/shared/lib/queue/client.ts:
```typescript
export const escalationQueue = new Queue('escalations', {
  connection: getQueueConnection(),
});

// Update closeQueueConnections to include:
await escalationQueue.close();
```

2. Create src/features/escalations/escalations.types.ts:
```typescript
import { z } from 'zod';
import type { TriggerConfig, EscalationStep } from '../../shared/db/schema/escalation-blocks';

/**
 * Escalation step schema
 */
export const escalationStepSchema = z.object({
  delayMinutes: z.number().min(0).max(10080), // Max 7 days
  targetType: z.enum(['role', 'user', 'reports_to']),
  targetRole: z.enum(['squad_lead', 'pm', 'admin']).optional(),
  targetUserId: z.string().uuid().optional(),
});

/**
 * Trigger config schema
 */
export const triggerConfigSchema = z.discriminatedUnion('type', [
  z.object({
    type: z.literal('blocker_reported'),
  }),
  z.object({
    type: z.literal('deadline_risk'),
    daysBeforeDue: z.number().min(1).max(30),
    minProgress: z.number().min(0).max(100), // Percentage
  }),
  z.object({
    type: z.literal('output_below_threshold'),
    periodDays: z.number().min(1).max(30),
    minOutput: z.number().min(1),
  }),
]);

/**
 * Create escalation block input
 */
export const createEscalationBlockSchema = z.object({
  name: z.string().min(1).max(255),
  description: z.string().max(1000).optional(),
  triggerType: z.enum(['blocker_reported', 'deadline_risk', 'output_below_threshold']),
  triggerConfig: triggerConfigSchema,
  escalationChain: z.array(escalationStepSchema).min(1).max(10),
  enabled: z.boolean().default(true),
});

export type CreateEscalationBlockInput = z.infer<typeof createEscalationBlockSchema>;

/**
 * Update escalation block input
 */
export const updateEscalationBlockSchema = createEscalationBlockSchema.partial();
export type UpdateEscalationBlockInput = z.infer<typeof updateEscalationBlockSchema>;

/**
 * Report blocker input
 */
export const reportBlockerSchema = z.object({
  targetType: z.enum(['task', 'deliverable', 'general']).default('general'),
  targetId: z.string().uuid().optional(),
  title: z.string().min(1).max(500),
  description: z.string().optional(),
});

export type ReportBlockerInput = z.infer<typeof reportBlockerSchema>;

/**
 * Resolve blocker input
 */
export const resolveBlockerSchema = z.object({
  resolutionNotes: z.string().optional(),
});

export type ResolveBlockerInput = z.infer<typeof resolveBlockerSchema>;

/**
 * Escalation job data
 */
export interface EscalationJobData {
  type: 'escalate';
  blockerId: string;
  escalationBlockId: string;
  stepIndex: number;
}

/**
 * Deadline monitor job data
 */
export interface DeadlineMonitorJobData {
  type: 'check_deadlines' | 'check_output';
  projectId: string;
}
```

3. Create src/features/escalations/escalations.service.ts:
```typescript
import { and, eq, gte, sql } from 'drizzle-orm';
import dayjs from 'dayjs';
import { db, schema } from '../../shared/db';
import { logger } from '../../shared/lib/logger';
import { escalationQueue } from '../../shared/lib/queue/client';
import type { EscalationStep, TriggerConfig } from '../../shared/db/schema/escalation-blocks';
import type {
  CreateEscalationBlockInput,
  UpdateEscalationBlockInput,
  ReportBlockerInput,
  ResolveBlockerInput,
} from './escalations.types';

/**
 * Create escalation block
 */
export async function createEscalationBlock(
  projectId: string,
  createdById: string,
  input: CreateEscalationBlockInput
): Promise<typeof schema.escalationBlocks.$inferSelect> {
  const [block] = await db
    .insert(schema.escalationBlocks)
    .values({
      projectId,
      createdById,
      name: input.name,
      description: input.description ?? null,
      triggerType: input.triggerType,
      triggerConfig: input.triggerConfig as TriggerConfig,
      escalationChain: input.escalationChain as EscalationStep[],
      enabled: input.enabled,
    })
    .returning();

  logger.info({ blockId: block.id, projectId, triggerType: input.triggerType }, 'Escalation block created');
  return block;
}

/**
 * Update escalation block
 */
export async function updateEscalationBlock(
  blockId: string,
  projectId: string,
  input: UpdateEscalationBlockInput
): Promise<typeof schema.escalationBlocks.$inferSelect | null> {
  const updateData: Record<string, unknown> = { updatedAt: new Date() };

  if (input.name !== undefined) updateData.name = input.name;
  if (input.description !== undefined) updateData.description = input.description;
  if (input.triggerType !== undefined) updateData.triggerType = input.triggerType;
  if (input.triggerConfig !== undefined) updateData.triggerConfig = input.triggerConfig;
  if (input.escalationChain !== undefined) updateData.escalationChain = input.escalationChain;
  if (input.enabled !== undefined) updateData.enabled = input.enabled;

  const [block] = await db
    .update(schema.escalationBlocks)
    .set(updateData)
    .where(and(
      eq(schema.escalationBlocks.id, blockId),
      eq(schema.escalationBlocks.projectId, projectId)
    ))
    .returning();

  return block ?? null;
}

/**
 * Delete escalation block
 */
export async function deleteEscalationBlock(
  blockId: string,
  projectId: string
): Promise<boolean> {
  const result = await db
    .delete(schema.escalationBlocks)
    .where(and(
      eq(schema.escalationBlocks.id, blockId),
      eq(schema.escalationBlocks.projectId, projectId)
    ))
    .returning({ id: schema.escalationBlocks.id });

  return result.length > 0;
}

/**
 * List escalation blocks for project
 */
export async function listEscalationBlocks(
  projectId: string
): Promise<Array<typeof schema.escalationBlocks.$inferSelect>> {
  return db.query.escalationBlocks.findMany({
    where: eq(schema.escalationBlocks.projectId, projectId),
    orderBy: (table, { desc }) => [desc(table.createdAt)],
  });
}

/**
 * Report a blocker
 */
export async function reportBlocker(
  projectId: string,
  reportedById: string,
  input: ReportBlockerInput
): Promise<string> {
  // Create blocker record
  const [blocker] = await db
    .insert(schema.blockers)
    .values({
      projectId,
      reportedById,
      targetType: input.targetType,
      targetId: input.targetId ?? null,
      title: input.title,
      description: input.description ?? null,
      status: 'open',
    })
    .returning();

  logger.info({ blockerId: blocker.id, projectId, reportedById }, 'Blocker reported');

  // Find applicable escalation blocks
  const escalationBlocks = await db.query.escalationBlocks.findMany({
    where: and(
      eq(schema.escalationBlocks.projectId, projectId),
      eq(schema.escalationBlocks.triggerType, 'blocker_reported'),
      eq(schema.escalationBlocks.enabled, true)
    ),
  });

  // Start escalation chain for each block
  for (const block of escalationBlocks) {
    await startEscalationChain(blocker.id, block);
  }

  return blocker.id;
}

/**
 * Resolve a blocker
 */
export async function resolveBlocker(
  blockerId: string,
  resolvedById: string,
  input: ResolveBlockerInput
): Promise<boolean> {
  const [blocker] = await db
    .update(schema.blockers)
    .set({
      status: 'resolved',
      resolvedById,
      resolvedAt: new Date(),
      resolutionNotes: input.resolutionNotes ?? null,
      updatedAt: new Date(),
    })
    .where(eq(schema.blockers.id, blockerId))
    .returning();

  if (!blocker) return false;

  logger.info({ blockerId, resolvedById }, 'Blocker resolved');

  // Cancel pending escalation jobs
  await cancelEscalationJobs(blockerId);

  // Notify escalated parties that blocker is resolved
  await notifyBlockerResolved(blocker);

  return true;
}

/**
 * Get blocker by ID
 */
export async function getBlocker(
  blockerId: string
): Promise<typeof schema.blockers.$inferSelect | null> {
  const blocker = await db.query.blockers.findFirst({
    where: eq(schema.blockers.id, blockerId),
  });
  return blocker ?? null;
}

/**
 * List blockers for project
 */
export async function listBlockers(
  projectId: string,
  status?: string
): Promise<Array<typeof schema.blockers.$inferSelect>> {
  const conditions = [eq(schema.blockers.projectId, projectId)];
  if (status) {
    conditions.push(eq(schema.blockers.status, status));
  }

  return db.query.blockers.findMany({
    where: and(...conditions),
    orderBy: (table, { desc }) => [desc(table.createdAt)],
  });
}

/**
 * Start escalation chain for a blocker
 */
export async function startEscalationChain(
  blockerId: string,
  block: typeof schema.escalationBlocks.$inferSelect
): Promise<void> {
  const chain = block.escalationChain as EscalationStep[];
  if (chain.length === 0) return;

  const firstStep = chain[0];

  logger.info({ blockerId, escalationBlockId: block.id }, 'Starting escalation chain');

  // Schedule first step (may be immediate if delayMinutes = 0)
  await escalationQueue.add(
    `escalate-${blockerId}-${block.id}-0`,
    {
      type: 'escalate',
      blockerId,
      escalationBlockId: block.id,
      stepIndex: 0,
    },
    {
      delay: firstStep.delayMinutes * 60 * 1000,
      jobId: `escalate-${blockerId}-${block.id}-0`,
    }
  );
}

/**
 * Cancel all pending escalation jobs for a blocker
 */
export async function cancelEscalationJobs(blockerId: string): Promise<void> {
  const delayed = await escalationQueue.getDelayed();

  for (const job of delayed) {
    if (job.data.blockerId === blockerId) {
      await job.remove();
      logger.info({ jobId: job.id, blockerId }, 'Cancelled escalation job');
    }
  }
}

/**
 * Resolve escalation target based on step config
 */
export async function resolveEscalationTarget(
  step: EscalationStep,
  reporterId: string,
  projectId: string
): Promise<string | null> {
  switch (step.targetType) {
    case 'reports_to': {
      // Follow reportsToUserId chain from reporter
      const member = await db.query.projectMembers.findFirst({
        where: and(
          eq(schema.projectMembers.userId, reporterId),
          eq(schema.projectMembers.projectId, projectId)
        ),
        columns: { reportsToUserId: true },
      });
      return member?.reportsToUserId ?? null;
    }

    case 'role': {
      // Find first user with target role in project
      const member = await db.query.projectMembers.findFirst({
        where: and(
          eq(schema.projectMembers.projectId, projectId),
          eq(schema.projectMembers.role, step.targetRole!)
        ),
        columns: { userId: true },
      });
      return member?.userId ?? null;
    }

    case 'user':
      return step.targetUserId ?? null;
  }
}

/**
 * Format escalation message
 */
export function formatEscalationMessage(
  blocker: typeof schema.blockers.$inferSelect,
  stepIndex: number,
  reporterEmail: string
): string {
  const urgency = stepIndex === 0 ? '' : ` (Escalation level ${stepIndex + 1})`;
  const reporterName = reporterEmail.split('@')[0];

  return `Blocker Alert${urgency}

${reporterName} reported a blocker:

"${blocker.title}"

${blocker.description ? `Details: ${blocker.description}\n\n` : ''}Reported: ${dayjs(blocker.createdAt).fromNow()}

Reply with "resolve ${blocker.id.slice(0, 8)}" to mark as resolved.`;
}

/**
 * Notify escalated parties when blocker is resolved
 */
async function notifyBlockerResolved(
  blocker: typeof schema.blockers.$inferSelect
): Promise<void> {
  // Get reporter info for message
  const reporter = await db.query.users.findFirst({
    where: eq(schema.users.id, blocker.reportedById),
    columns: { email: true },
  });

  if (!reporter) return;

  const message = `Blocker Resolved

"${blocker.title}" has been resolved.

${blocker.resolutionNotes ? `Resolution: ${blocker.resolutionNotes}` : ''}`;

  // In a full implementation, we'd track who was notified and notify them
  // For now, just log
  logger.info({ blockerId: blocker.id }, 'Blocker resolution notification would be sent');
}
```

4. Create src/features/escalations/escalations.worker.ts:
```typescript
import { Worker } from 'bullmq';
import { eq } from 'drizzle-orm';
import { db, schema } from '../../shared/db';
import { logger } from '../../shared/lib/logger';
import { getQueueConnection, escalationQueue } from '../../shared/lib/queue/client';
import { registerWorker } from '../../shared/lib/queue/workers';
import { sendTelegramMessage } from '../telegram';
import { sendWhatsAppMessage } from '../whatsapp/whatsapp.client';
import {
  resolveEscalationTarget,
  formatEscalationMessage,
} from './escalations.service';
import type { EscalationStep } from '../../shared/db/schema/escalation-blocks';
import type { EscalationJobData } from './escalations.types';

/**
 * Deliver escalation message to user
 */
async function deliverEscalationMessage(userId: string, message: string): Promise<boolean> {
  const userMessaging = await db.query.userMessaging.findFirst({
    where: eq(schema.userMessaging.userId, userId),
  });

  if (!userMessaging?.messagingEnabled) {
    logger.info({ userId }, 'Messaging disabled, skipping escalation delivery');
    return false;
  }

  let delivered = false;

  if (userMessaging.telegramChatId && userMessaging.telegramVerified) {
    try {
      await sendTelegramMessage(userMessaging.telegramChatId, message);
      delivered = true;
    } catch (err) {
      logger.error({ err, userId }, 'Failed to deliver escalation via Telegram');
    }
  }

  if (userMessaging.whatsappPhone && userMessaging.whatsappVerified) {
    try {
      await sendWhatsAppMessage(userMessaging.whatsappPhone, message);
      delivered = true;
    } catch (err) {
      logger.error({ err, userId }, 'Failed to deliver escalation via WhatsApp');
    }
  }

  return delivered;
}

/**
 * Escalation worker - processes time-windowed escalation steps
 */
export const escalationWorker = new Worker<EscalationJobData>(
  'escalations',
  async (job) => {
    const { blockerId, escalationBlockId, stepIndex } = job.data;
    logger.info({ jobId: job.id, blockerId, stepIndex }, 'Processing escalation step');

    // Check if blocker still exists and is unresolved
    const blocker = await db.query.blockers.findFirst({
      where: eq(schema.blockers.id, blockerId),
    });

    if (!blocker) {
      logger.warn({ blockerId }, 'Blocker not found, skipping escalation');
      return;
    }

    if (blocker.status === 'resolved') {
      logger.info({ blockerId }, 'Blocker already resolved, skipping escalation');
      return;
    }

    // Get escalation block config
    const block = await db.query.escalationBlocks.findFirst({
      where: eq(schema.escalationBlocks.id, escalationBlockId),
    });

    if (!block || !block.enabled) {
      logger.info({ escalationBlockId }, 'Escalation block not found or disabled');
      return;
    }

    const chain = block.escalationChain as EscalationStep[];
    const step = chain[stepIndex];
    if (!step) {
      logger.warn({ stepIndex, chainLength: chain.length }, 'Step index out of bounds');
      return;
    }

    // Find escalation target
    const targetUserId = await resolveEscalationTarget(
      step,
      blocker.reportedById,
      blocker.projectId
    );

    if (targetUserId) {
      // Get reporter info for message
      const reporter = await db.query.users.findFirst({
        where: eq(schema.users.id, blocker.reportedById),
        columns: { email: true },
      });

      // Send escalation notification
      const message = formatEscalationMessage(
        blocker,
        stepIndex,
        reporter?.email ?? 'Unknown'
      );
      await deliverEscalationMessage(targetUserId, message);

      // Update blocker state
      await db
        .update(schema.blockers)
        .set({
          status: 'escalated',
          currentEscalationStep: stepIndex,
          lastEscalatedAt: new Date(),
          updatedAt: new Date(),
        })
        .where(eq(schema.blockers.id, blockerId));

      logger.info({ blockerId, stepIndex, targetUserId }, 'Escalation delivered');
    } else {
      logger.warn({ blockerId, stepIndex, targetType: step.targetType }, 'No target found for escalation');
    }

    // Schedule next step if exists
    const nextStep = chain[stepIndex + 1];
    if (nextStep) {
      await escalationQueue.add(
        `escalate-${blockerId}-${escalationBlockId}-${stepIndex + 1}`,
        {
          type: 'escalate',
          blockerId,
          escalationBlockId,
          stepIndex: stepIndex + 1,
        },
        {
          delay: nextStep.delayMinutes * 60 * 1000,
          jobId: `escalate-${blockerId}-${escalationBlockId}-${stepIndex + 1}`,
        }
      );
      logger.info({ blockerId, nextStep: stepIndex + 1, delay: nextStep.delayMinutes }, 'Scheduled next escalation step');
    }
  },
  {
    connection: getQueueConnection(),
    concurrency: 10,
  }
);

// Register for graceful shutdown
registerWorker(escalationWorker);

export { escalationQueue };
```
  </action>
  <verify>bun run typecheck passes</verify>
  <done>Escalation service and worker with time-windowed chains implemented</done>
</task>

<task type="auto">
  <name>Task 3: Create deadline monitor and messaging integration</name>
  <files>src/features/escalations/deadline-monitor.worker.ts, src/features/escalations/escalations.routes.ts, src/features/escalations/index.ts, src/features/messaging/messaging.intents.ts, src/features/messaging/messaging.service.ts, src/index.ts</files>
  <action>
1. Create src/features/escalations/deadline-monitor.worker.ts:
```typescript
import { Worker, Queue } from 'bullmq';
import { and, eq, gte, lte, sql, ne } from 'drizzle-orm';
import dayjs from 'dayjs';
import { db, schema } from '../../shared/db';
import { logger } from '../../shared/lib/logger';
import { getQueueConnection } from '../../shared/lib/queue/client';
import { registerWorker } from '../../shared/lib/queue/workers';
import { sendTelegramMessage } from '../telegram';
import { sendWhatsAppMessage } from '../whatsapp/whatsapp.client';
import { reportBlocker, startEscalationChain } from './escalations.service';
import type { TriggerConfig } from '../../shared/db/schema/escalation-blocks';
import type { DeadlineMonitorJobData } from './escalations.types';

export const deadlineMonitorQueue = new Queue('deadline-monitor', {
  connection: getQueueConnection(),
});

/**
 * Deliver alert message to user
 */
async function deliverAlert(userId: string, message: string): Promise<void> {
  const userMessaging = await db.query.userMessaging.findFirst({
    where: eq(schema.userMessaging.userId, userId),
  });

  if (!userMessaging?.messagingEnabled) return;

  if (userMessaging.telegramChatId && userMessaging.telegramVerified) {
    try {
      await sendTelegramMessage(userMessaging.telegramChatId, message);
    } catch (err) {
      logger.error({ err, userId }, 'Failed to deliver alert via Telegram');
    }
  }

  if (userMessaging.whatsappPhone && userMessaging.whatsappVerified) {
    try {
      await sendWhatsAppMessage(userMessaging.whatsappPhone, message);
    } catch (err) {
      logger.error({ err, userId }, 'Failed to deliver alert via WhatsApp');
    }
  }
}

/**
 * Check for deadline risks in a project
 */
async function checkDeadlineRisks(projectId: string): Promise<void> {
  // Get escalation blocks with deadline_risk trigger
  const blocks = await db.query.escalationBlocks.findMany({
    where: and(
      eq(schema.escalationBlocks.projectId, projectId),
      eq(schema.escalationBlocks.triggerType, 'deadline_risk'),
      eq(schema.escalationBlocks.enabled, true)
    ),
  });

  const now = new Date();

  for (const block of blocks) {
    const config = block.triggerConfig as TriggerConfig & { type: 'deadline_risk' };
    const riskDate = dayjs(now).add(config.daysBeforeDue, 'day').toDate();

    // Find at-risk deliverables (due soon, not completed)
    const atRiskItems = await db.query.deliverables.findMany({
      where: and(
        eq(schema.deliverables.projectId, projectId),
        lte(schema.deliverables.dueDate, riskDate),
        gte(schema.deliverables.dueDate, now),
        sql`${schema.deliverables.completedAt} IS NULL`
      ),
    });

    for (const item of atRiskItems) {
      // Check if already escalated recently (within 24 hours)
      const existingBlocker = await db.query.blockers.findFirst({
        where: and(
          eq(schema.blockers.targetType, 'deliverable'),
          eq(schema.blockers.targetId, item.id),
          ne(schema.blockers.status, 'resolved'),
          gte(schema.blockers.createdAt, dayjs(now).subtract(24, 'hour').toDate())
        ),
      });

      if (existingBlocker) {
        logger.debug({ deliverableId: item.id }, 'Already escalated recently, skipping');
        continue;
      }

      // Create system-generated blocker
      const assigneeId = item.assigneeId ?? item.createdById;
      const dueDate = dayjs(item.dueDate).format('MMM D, YYYY');

      const blockerId = await reportBlocker(projectId, assigneeId, {
        targetType: 'deliverable',
        targetId: item.id,
        title: `Deadline risk: "${item.title}" due ${dueDate}`,
        description: `This deliverable is due on ${dueDate} but hasn't been completed.`,
      });

      // Also send direct alert to assignee
      const message = `Deadline Risk Alert

"${item.title}" is due in ${config.daysBeforeDue} day${config.daysBeforeDue > 1 ? 's' : ''}.

Due: ${dueDate}
Status: ${item.status}

Please update progress or request help if needed.`;

      await deliverAlert(assigneeId, message);

      logger.info({ deliverableId: item.id, assigneeId }, 'Deadline risk alert sent');
    }
  }
}

/**
 * Check for low output users in a project
 */
async function checkOutputThresholds(projectId: string): Promise<void> {
  // Get escalation blocks with output_below_threshold trigger
  const blocks = await db.query.escalationBlocks.findMany({
    where: and(
      eq(schema.escalationBlocks.projectId, projectId),
      eq(schema.escalationBlocks.triggerType, 'output_below_threshold'),
      eq(schema.escalationBlocks.enabled, true)
    ),
  });

  const now = new Date();

  for (const block of blocks) {
    const config = block.triggerConfig as TriggerConfig & { type: 'output_below_threshold' };
    const periodStart = dayjs(now).subtract(config.periodDays, 'day').toDate();

    // Get all project members
    const members = await db.query.projectMembers.findMany({
      where: eq(schema.projectMembers.projectId, projectId),
      columns: { userId: true, role: true },
    });

    for (const member of members) {
      // Skip admins/PMs from output monitoring
      if (member.role === 'admin' || member.role === 'pm') continue;

      // Count completed deliverables in period
      const [result] = await db
        .select({ count: sql<number>`count(*)` })
        .from(schema.deliverables)
        .where(and(
          eq(schema.deliverables.assigneeId, member.userId),
          eq(schema.deliverables.projectId, projectId),
          gte(schema.deliverables.completedAt, periodStart),
          lte(schema.deliverables.completedAt, now)
        ));

      const output = Number(result?.count ?? 0);

      if (output < config.minOutput) {
        // Check if already warned recently
        const existingBlocker = await db.query.blockers.findFirst({
          where: and(
            eq(schema.blockers.reportedById, member.userId),
            eq(schema.blockers.projectId, projectId),
            sql`${schema.blockers.title} LIKE 'Output warning:%'`,
            gte(schema.blockers.createdAt, dayjs(now).subtract(config.periodDays, 'day').toDate())
          ),
        });

        if (existingBlocker) continue;

        // Get user info
        const user = await db.query.users.findFirst({
          where: eq(schema.users.id, member.userId),
          columns: { email: true },
        });

        const userName = user?.email?.split('@')[0] ?? 'User';

        // Create blocker for tracking
        await reportBlocker(projectId, member.userId, {
          targetType: 'general',
          title: `Output warning: ${userName} below threshold`,
          description: `Output of ${output} deliverables in last ${config.periodDays} days is below minimum of ${config.minOutput}.`,
        });

        // Send alert to user
        const message = `Output Threshold Warning

Your deliverable output over the last ${config.periodDays} days is ${output}, which is below the expected minimum of ${config.minOutput}.

If you're blocked on something, please report it so we can help.
If you're on PTO or have other circumstances, please let your lead know.`;

        await deliverAlert(member.userId, message);

        logger.info({ userId: member.userId, output, threshold: config.minOutput }, 'Output threshold warning sent');
      }
    }
  }
}

/**
 * Deadline monitor worker
 */
export const deadlineMonitorWorker = new Worker<DeadlineMonitorJobData>(
  'deadline-monitor',
  async (job) => {
    const { type, projectId } = job.data;
    logger.info({ jobId: job.id, type, projectId }, 'Processing deadline monitor job');

    switch (type) {
      case 'check_deadlines':
        await checkDeadlineRisks(projectId);
        break;
      case 'check_output':
        await checkOutputThresholds(projectId);
        break;
    }
  },
  {
    connection: getQueueConnection(),
    concurrency: 5,
  }
);

// Register for graceful shutdown
registerWorker(deadlineMonitorWorker);

/**
 * Schedule periodic deadline and output checks for a project
 */
export async function scheduleDeadlineMonitoring(projectId: string): Promise<void> {
  // Check deadlines every 4 hours
  await deadlineMonitorQueue.add(
    `deadline-check-${projectId}`,
    { type: 'check_deadlines', projectId },
    {
      repeat: { pattern: '0 */4 * * *' }, // Every 4 hours
      jobId: `deadline-check-${projectId}`,
    }
  );

  // Check output daily at 6 PM
  await deadlineMonitorQueue.add(
    `output-check-${projectId}`,
    { type: 'check_output', projectId },
    {
      repeat: { pattern: '0 18 * * *' }, // 6 PM daily
      jobId: `output-check-${projectId}`,
    }
  );

  logger.info({ projectId }, 'Scheduled deadline monitoring');
}

export { deadlineMonitorQueue };
```

2. Create src/features/escalations/escalations.routes.ts:
```typescript
import { Hono } from 'hono';
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';
import { authMiddleware, type AuthContext } from '../auth/auth.middleware';
import { visibilityMiddleware, type VisibilityContext } from '../visibility/visibility.middleware';
import { ApiError } from '../../shared/types';
import {
  createEscalationBlock,
  updateEscalationBlock,
  deleteEscalationBlock,
  listEscalationBlocks,
  reportBlocker,
  resolveBlocker,
  getBlocker,
  listBlockers,
} from './escalations.service';
import { scheduleDeadlineMonitoring } from './deadline-monitor.worker';
import {
  createEscalationBlockSchema,
  updateEscalationBlockSchema,
  reportBlockerSchema,
  resolveBlockerSchema,
} from './escalations.types';

type EscalationContext = AuthContext & VisibilityContext;
const app = new Hono<EscalationContext>();

app.use('*', authMiddleware);
app.use('*', visibilityMiddleware);

// Project-scoped escalation block routes
const blockRoutes = new Hono<EscalationContext>();

// List escalation blocks
blockRoutes.get('/', async (c) => {
  const projectId = c.req.param('projectId');

  const visibleProjectIds = c.get('visibleProjectIds');
  if (!visibleProjectIds.includes(projectId)) {
    throw new ApiError(403, 'Access denied to this project');
  }

  const blocks = await listEscalationBlocks(projectId);
  return c.json({ data: blocks });
});

// Create escalation block
blockRoutes.post(
  '/',
  zValidator('json', createEscalationBlockSchema),
  async (c) => {
    const projectId = c.req.param('projectId');
    const userId = c.get('userId');
    const input = c.req.valid('json');

    const visibleProjectIds = c.get('visibleProjectIds');
    if (!visibleProjectIds.includes(projectId)) {
      throw new ApiError(403, 'Access denied to this project');
    }

    const block = await createEscalationBlock(projectId, userId, input);
    return c.json({ data: block }, 201);
  }
);

// Update escalation block
blockRoutes.patch(
  '/:blockId',
  zValidator('json', updateEscalationBlockSchema),
  async (c) => {
    const projectId = c.req.param('projectId');
    const blockId = c.req.param('blockId');
    const input = c.req.valid('json');

    const visibleProjectIds = c.get('visibleProjectIds');
    if (!visibleProjectIds.includes(projectId)) {
      throw new ApiError(403, 'Access denied to this project');
    }

    const block = await updateEscalationBlock(blockId, projectId, input);
    if (!block) {
      throw new ApiError(404, 'Escalation block not found');
    }

    return c.json({ data: block });
  }
);

// Delete escalation block
blockRoutes.delete('/:blockId', async (c) => {
  const projectId = c.req.param('projectId');
  const blockId = c.req.param('blockId');

  const visibleProjectIds = c.get('visibleProjectIds');
  if (!visibleProjectIds.includes(projectId)) {
    throw new ApiError(403, 'Access denied to this project');
  }

  const deleted = await deleteEscalationBlock(blockId, projectId);
  if (!deleted) {
    throw new ApiError(404, 'Escalation block not found');
  }

  return c.json({ data: { deleted: true } });
});

// Enable deadline monitoring
blockRoutes.post('/enable-monitoring', async (c) => {
  const projectId = c.req.param('projectId');

  const visibleProjectIds = c.get('visibleProjectIds');
  if (!visibleProjectIds.includes(projectId)) {
    throw new ApiError(403, 'Access denied to this project');
  }

  await scheduleDeadlineMonitoring(projectId);
  return c.json({ data: { enabled: true } });
});

// Project-scoped blocker routes
const blockerRoutes = new Hono<EscalationContext>();

// List blockers
blockerRoutes.get('/', async (c) => {
  const projectId = c.req.param('projectId');
  const status = c.req.query('status');

  const visibleProjectIds = c.get('visibleProjectIds');
  if (!visibleProjectIds.includes(projectId)) {
    throw new ApiError(403, 'Access denied to this project');
  }

  const blockers = await listBlockers(projectId, status);
  return c.json({ data: blockers });
});

// Report blocker
blockerRoutes.post(
  '/',
  zValidator('json', reportBlockerSchema),
  async (c) => {
    const projectId = c.req.param('projectId');
    const userId = c.get('userId');
    const input = c.req.valid('json');

    const visibleProjectIds = c.get('visibleProjectIds');
    if (!visibleProjectIds.includes(projectId)) {
      throw new ApiError(403, 'Access denied to this project');
    }

    const blockerId = await reportBlocker(projectId, userId, input);
    return c.json({ data: { id: blockerId } }, 201);
  }
);

// Get blocker
blockerRoutes.get('/:blockerId', async (c) => {
  const projectId = c.req.param('projectId');
  const blockerId = c.req.param('blockerId');

  const visibleProjectIds = c.get('visibleProjectIds');
  if (!visibleProjectIds.includes(projectId)) {
    throw new ApiError(403, 'Access denied to this project');
  }

  const blocker = await getBlocker(blockerId);
  if (!blocker || blocker.projectId !== projectId) {
    throw new ApiError(404, 'Blocker not found');
  }

  return c.json({ data: blocker });
});

// Resolve blocker
blockerRoutes.post(
  '/:blockerId/resolve',
  zValidator('json', resolveBlockerSchema),
  async (c) => {
    const projectId = c.req.param('projectId');
    const blockerId = c.req.param('blockerId');
    const userId = c.get('userId');
    const input = c.req.valid('json');

    const visibleProjectIds = c.get('visibleProjectIds');
    if (!visibleProjectIds.includes(projectId)) {
      throw new ApiError(403, 'Access denied to this project');
    }

    const blocker = await getBlocker(blockerId);
    if (!blocker || blocker.projectId !== projectId) {
      throw new ApiError(404, 'Blocker not found');
    }

    const resolved = await resolveBlocker(blockerId, userId, input);
    if (!resolved) {
      throw new ApiError(400, 'Failed to resolve blocker');
    }

    return c.json({ data: { resolved: true } });
  }
);

// Mount routes
app.route('/projects/:projectId/escalation-blocks', blockRoutes);
app.route('/projects/:projectId/blockers', blockerRoutes);

export default app;
```

3. Create src/features/escalations/index.ts:
```typescript
export { default as escalationsRoutes } from './escalations.routes';
export { escalationWorker, escalationQueue } from './escalations.worker';
export { deadlineMonitorWorker, deadlineMonitorQueue, scheduleDeadlineMonitoring } from './deadline-monitor.worker';
export {
  createEscalationBlock,
  updateEscalationBlock,
  deleteEscalationBlock,
  listEscalationBlocks,
  reportBlocker,
  resolveBlocker,
  getBlocker,
  listBlockers,
  startEscalationChain,
  cancelEscalationJobs,
  resolveEscalationTarget,
  formatEscalationMessage,
} from './escalations.service';
export type {
  CreateEscalationBlockInput,
  UpdateEscalationBlockInput,
  ReportBlockerInput,
  ResolveBlockerInput,
  EscalationJobData,
  DeadlineMonitorJobData,
} from './escalations.types';
```

4. Update src/features/messaging/messaging.intents.ts to add report_blocker intent:
```typescript
// Add to the intents array:
'report_blocker', // "I'm blocked on X", "Stuck on Y"

// Add to entities in the function definition:
blockerDescription: {
  type: 'string',
  description: 'What is blocking the user',
},
blockedItem: {
  type: 'string',
  description: 'Task or deliverable that is blocked (if specified)',
},

// Add to system prompt intent descriptions:
`- report_blocker: User reporting they are blocked on something ("I'm stuck on", "blocked by", "can't proceed", "need help with")`
```

5. Update src/features/messaging/messaging.service.ts to handle report_blocker intent:
```typescript
// Add import at top
import { reportBlocker } from '../escalations';

// Add case in intent handler switch:
case 'report_blocker': {
  if (!userContext.lastProjectId) {
    return {
      response: "Please select a project first using 'use project [name]' to report a blocker.",
    };
  }

  const description = intent.entities?.blockerDescription
    || intent.entities?.blockedItem
    || message;

  const blockerId = await reportBlocker(userContext.lastProjectId, userId, {
    targetType: 'general',
    title: description.slice(0, 500),
    description: `Reported via ${platform} messaging`,
  });

  return {
    response: `Blocker reported! Your manager and team leads will be notified according to escalation rules. Blocker ID: ${blockerId.slice(0, 8)}`,
  };
}
```

6. Register routes and import workers in src/index.ts:
```typescript
// Add imports
import { escalationsRoutes } from './features/escalations';
import './features/escalations/escalations.worker';
import './features/escalations/deadline-monitor.worker';

// Add route
app.route('/api/v1/escalations', escalationsRoutes);
```
  </action>
  <verify>bun run typecheck passes, bun run lint passes</verify>
  <done>Escalation system with deadline monitoring and messaging integration complete</done>
</task>

</tasks>

<verification>
- [ ] Migration creates escalation_blocks and blockers tables
- [ ] POST /api/v1/escalations/projects/:id/escalation-blocks creates block with trigger config
- [ ] GET /api/v1/escalations/projects/:id/blockers lists project blockers
- [ ] POST /api/v1/escalations/projects/:id/blockers reports new blocker
- [ ] POST /api/v1/escalations/projects/:id/blockers/:id/resolve resolves blocker
- [ ] Reporting blocker triggers escalation chain based on configured blocks
- [ ] Escalation messages sent via Telegram/WhatsApp
- [ ] Time-windowed escalation (delayed jobs) process correctly
- [ ] Deadline monitor checks for at-risk deliverables
- [ ] Output threshold warnings sent for low output users
- [ ] Messaging intent "I'm blocked on X" creates blocker
- [ ] Resolving blocker cancels pending escalation jobs
- [ ] bun run typecheck and bun run lint pass
</verification>

<success_criteria>
- Admin can create escalation blocks with blocker_reported, deadline_risk, or output_below_threshold triggers
- Escalation chains support time-windowed routing (immediate, 4hr, 24hr etc.)
- Escalations route to reports_to chain, specific roles, or specific users
- Users can report blockers via messaging ("I'm blocked on...")
- Squad leads can mark blockers as resolved, cancelling pending escalations
- Deadline risk alerts proactively sent for at-risk deliverables
- Output threshold warnings sent when user output drops below minimum
</success_criteria>

<output>
After completion, create `.planning/phases/06-check-ins-escalations/06-03-SUMMARY.md`
</output>
