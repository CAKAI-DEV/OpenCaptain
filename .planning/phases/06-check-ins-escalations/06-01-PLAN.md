---
phase: 06-check-ins-escalations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/shared/db/schema/check-in-blocks.ts
  - src/shared/db/schema/check-in-responses.ts
  - src/shared/db/schema/index.ts
  - src/shared/db/migrations/0013_check_ins.sql
  - src/features/check-ins/check-ins.types.ts
  - src/features/check-ins/check-ins.templates.ts
  - src/features/check-ins/check-ins.service.ts
  - src/features/check-ins/check-ins.worker.ts
  - src/features/check-ins/check-ins.routes.ts
  - src/features/check-ins/index.ts
  - src/shared/lib/queue/client.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Admin can create check-in block with name, cron schedule, and questions"
    - "Admin can select from preset templates (daily_standup, output_count, weekly_forecast)"
    - "Check-in prompts delivered at scheduled times via Telegram/WhatsApp"
    - "Check-in questions support multiple types (text, number, select, boolean)"
    - "Admin can target check-ins to all users, specific squad, or specific role"
  artifacts:
    - path: "src/shared/db/schema/check-in-blocks.ts"
      provides: "Check-in block configuration schema"
      contains: "checkInBlocks"
    - path: "src/features/check-ins/check-ins.templates.ts"
      provides: "Preset check-in templates"
      exports: ["CHECK_IN_TEMPLATES", "getTemplate"]
    - path: "src/features/check-ins/check-ins.worker.ts"
      provides: "BullMQ worker for scheduled check-ins"
      contains: "checkInWorker"
    - path: "src/features/check-ins/check-ins.routes.ts"
      provides: "Admin API for check-in blocks"
      contains: "POST.*check-in-blocks"
  key_links:
    - from: "src/features/check-ins/check-ins.worker.ts"
      to: "sendTelegramMessage from ../telegram"
      via: "messaging delivery"
      pattern: "import.*sendTelegramMessage.*from.*telegram"
    - from: "src/features/check-ins/check-ins.service.ts"
      to: "checkInQueue"
      via: "schedule repeatable jobs"
      pattern: "checkInQueue\\.add.*repeat"
---

<objective>
Implement admin-configurable check-in blocks with scheduled delivery via messaging channels.

Purpose: Enable admins to create recurring check-in prompts (standup, output tracking, forecasts) that are delivered at scheduled times to targeted users (CHCK-01, CHCK-02, CHCK-03, CHCK-04).
Output: Check-in block schema, templates, scheduling service, delivery worker, and admin API.
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-check-ins-escalations/06-RESEARCH.md

@src/shared/db/schema/user-messaging.ts
@src/shared/db/schema/project-members.ts
@src/shared/db/schema/squads.ts
@src/shared/lib/queue/client.ts
@src/shared/lib/queue/workers.ts
@src/features/messaging/messaging.worker.ts
@src/features/telegram/index.ts
@src/features/whatsapp/whatsapp.client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create check-in schemas and migration</name>
  <files>src/shared/db/schema/check-in-blocks.ts, src/shared/db/schema/check-in-responses.ts, src/shared/db/schema/index.ts, src/shared/db/migrations/0013_check_ins.sql</files>
  <action>
1. Create src/shared/db/schema/check-in-blocks.ts:
```typescript
import { relations } from 'drizzle-orm';
import { boolean, index, jsonb, pgTable, timestamp, uuid, varchar } from 'drizzle-orm/pg-core';
import { projects } from './projects';
import { users } from './users';
import { squads } from './squads';

/**
 * Check-in question types
 */
export interface CheckInQuestion {
  id: string;
  text: string;
  type: 'text' | 'number' | 'select' | 'boolean';
  options?: string[]; // For select type
  required: boolean;
}

/**
 * Check-in blocks - admin-configured recurring check-in prompts
 */
export const checkInBlocks = pgTable(
  'check_in_blocks',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    projectId: uuid('project_id')
      .notNull()
      .references(() => projects.id, { onDelete: 'cascade' }),
    createdById: uuid('created_by_id')
      .notNull()
      .references(() => users.id),

    name: varchar('name', { length: 255 }).notNull(),
    description: varchar('description', { length: 1000 }),

    // Scheduling (cron pattern + timezone)
    cronPattern: varchar('cron_pattern', { length: 50 }).notNull(), // e.g., '0 9 * * 1-5'
    timezone: varchar('timezone', { length: 50 }).default('UTC').notNull(),

    // Questions (ordered array stored as JSONB)
    questions: jsonb('questions').$type<CheckInQuestion[]>().notNull(),

    // Template reference (null = custom)
    templateId: varchar('template_id', { length: 50 }), // 'daily_standup', 'output_count', 'weekly_forecast'

    // Targeting: who receives this check-in
    targetType: varchar('target_type', { length: 20 }).notNull().default('all'), // 'all' | 'squad' | 'role'
    targetSquadId: uuid('target_squad_id').references(() => squads.id, { onDelete: 'set null' }),
    targetRole: varchar('target_role', { length: 50 }), // 'admin', 'pm', 'squad_lead', 'member'

    enabled: boolean('enabled').default(true).notNull(),

    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
  },
  (table) => [
    index('check_in_blocks_project_id_idx').on(table.projectId),
    index('check_in_blocks_enabled_idx').on(table.enabled),
  ]
);

export const checkInBlocksRelations = relations(checkInBlocks, ({ one }) => ({
  project: one(projects, {
    fields: [checkInBlocks.projectId],
    references: [projects.id],
  }),
  createdBy: one(users, {
    fields: [checkInBlocks.createdById],
    references: [users.id],
  }),
  targetSquad: one(squads, {
    fields: [checkInBlocks.targetSquadId],
    references: [squads.id],
  }),
}));
```

2. Create src/shared/db/schema/check-in-responses.ts:
```typescript
import { relations } from 'drizzle-orm';
import { index, jsonb, pgTable, timestamp, uuid, varchar } from 'drizzle-orm/pg-core';
import { checkInBlocks } from './check-in-blocks';
import { users } from './users';

/**
 * Individual question response
 */
export interface QuestionResponse {
  questionId: string;
  value: string | number | boolean | null;
}

/**
 * Check-in responses - user responses to check-in prompts
 */
export const checkInResponses = pgTable(
  'check_in_responses',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    checkInBlockId: uuid('check_in_block_id')
      .notNull()
      .references(() => checkInBlocks.id, { onDelete: 'cascade' }),
    userId: uuid('user_id')
      .notNull()
      .references(() => users.id, { onDelete: 'cascade' }),

    // Response status
    status: varchar('status', { length: 20 }).notNull().default('pending'), // 'pending' | 'completed' | 'skipped'

    // Responses to questions (JSONB array)
    responses: jsonb('responses').$type<QuestionResponse[]>(),

    // Timestamps
    sentAt: timestamp('sent_at', { withTimezone: true }).defaultNow().notNull(),
    completedAt: timestamp('completed_at', { withTimezone: true }),

    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
  },
  (table) => [
    index('check_in_responses_block_id_idx').on(table.checkInBlockId),
    index('check_in_responses_user_id_idx').on(table.userId),
    index('check_in_responses_status_idx').on(table.status),
    index('check_in_responses_sent_at_idx').on(table.sentAt),
  ]
);

export const checkInResponsesRelations = relations(checkInResponses, ({ one }) => ({
  checkInBlock: one(checkInBlocks, {
    fields: [checkInResponses.checkInBlockId],
    references: [checkInBlocks.id],
  }),
  user: one(users, {
    fields: [checkInResponses.userId],
    references: [users.id],
  }),
}));
```

3. Update src/shared/db/schema/index.ts to export new schemas:
```typescript
// Add exports:
export * from './check-in-blocks';
export * from './check-in-responses';
```

4. Create migration src/shared/db/migrations/0013_check_ins.sql:
```sql
-- Check-in blocks table
CREATE TABLE IF NOT EXISTS check_in_blocks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
  created_by_id UUID NOT NULL REFERENCES users(id),

  name VARCHAR(255) NOT NULL,
  description VARCHAR(1000),

  cron_pattern VARCHAR(50) NOT NULL,
  timezone VARCHAR(50) NOT NULL DEFAULT 'UTC',

  questions JSONB NOT NULL,
  template_id VARCHAR(50),

  target_type VARCHAR(20) NOT NULL DEFAULT 'all',
  target_squad_id UUID REFERENCES squads(id) ON DELETE SET NULL,
  target_role VARCHAR(50),

  enabled BOOLEAN NOT NULL DEFAULT true,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS check_in_blocks_project_id_idx ON check_in_blocks(project_id);
CREATE INDEX IF NOT EXISTS check_in_blocks_enabled_idx ON check_in_blocks(enabled);

-- Check-in responses table
CREATE TABLE IF NOT EXISTS check_in_responses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  check_in_block_id UUID NOT NULL REFERENCES check_in_blocks(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

  status VARCHAR(20) NOT NULL DEFAULT 'pending',
  responses JSONB,

  sent_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  completed_at TIMESTAMPTZ,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS check_in_responses_block_id_idx ON check_in_responses(check_in_block_id);
CREATE INDEX IF NOT EXISTS check_in_responses_user_id_idx ON check_in_responses(user_id);
CREATE INDEX IF NOT EXISTS check_in_responses_status_idx ON check_in_responses(status);
CREATE INDEX IF NOT EXISTS check_in_responses_sent_at_idx ON check_in_responses(sent_at);
```

5. Update migrations meta/_journal.json to add entry 13.
  </action>
  <verify>bun run db:generate succeeds, bun run typecheck passes</verify>
  <done>Check-in schema with blocks and responses tables created</done>
</task>

<task type="auto">
  <name>Task 2: Create check-in types, templates, and service</name>
  <files>src/features/check-ins/check-ins.types.ts, src/features/check-ins/check-ins.templates.ts, src/features/check-ins/check-ins.service.ts</files>
  <action>
1. Create src/features/check-ins/check-ins.types.ts:
```typescript
import { z } from 'zod';
import type { CheckInQuestion } from '../../shared/db/schema/check-in-blocks';

/**
 * Question schema for validation
 */
export const questionSchema = z.object({
  id: z.string().uuid(),
  text: z.string().min(1).max(500),
  type: z.enum(['text', 'number', 'select', 'boolean']),
  options: z.array(z.string()).optional(),
  required: z.boolean(),
});

/**
 * Create check-in block input
 */
export const createCheckInBlockSchema = z.object({
  name: z.string().min(1).max(255),
  description: z.string().max(1000).optional(),
  cronPattern: z.string().min(1).max(50),
  timezone: z.string().max(50).default('UTC'),
  questions: z.array(questionSchema).min(1).max(20),
  templateId: z.string().max(50).optional(),
  targetType: z.enum(['all', 'squad', 'role']).default('all'),
  targetSquadId: z.string().uuid().optional(),
  targetRole: z.enum(['admin', 'pm', 'squad_lead', 'member']).optional(),
  enabled: z.boolean().default(true),
});

export type CreateCheckInBlockInput = z.infer<typeof createCheckInBlockSchema>;

/**
 * Update check-in block input
 */
export const updateCheckInBlockSchema = createCheckInBlockSchema.partial();
export type UpdateCheckInBlockInput = z.infer<typeof updateCheckInBlockSchema>;

/**
 * Check-in job data for BullMQ
 */
export interface CheckInJobData {
  type: 'send_check_in';
  checkInBlockId: string;
  userId: string;
}

/**
 * Check-in block result with computed fields
 */
export interface CheckInBlockResult {
  id: string;
  projectId: string;
  createdById: string;
  name: string;
  description: string | null;
  cronPattern: string;
  timezone: string;
  questions: CheckInQuestion[];
  templateId: string | null;
  targetType: string;
  targetSquadId: string | null;
  targetRole: string | null;
  enabled: boolean;
  createdAt: Date;
  updatedAt: Date;
}
```

2. Create src/features/check-ins/check-ins.templates.ts:
```typescript
import { v4 as uuid } from 'uuid';
import type { CheckInQuestion } from '../../shared/db/schema/check-in-blocks';

/**
 * Preset check-in templates
 */
export const CHECK_IN_TEMPLATES = {
  daily_standup: {
    id: 'daily_standup',
    name: 'Daily Standup',
    description: 'Classic standup questions for daily sync',
    questions: [
      { id: uuid(), text: 'What did you accomplish yesterday?', type: 'text' as const, required: true },
      { id: uuid(), text: 'What are you working on today?', type: 'text' as const, required: true },
      { id: uuid(), text: 'Any blockers or concerns?', type: 'text' as const, required: false },
    ],
    defaultCron: '0 9 * * 1-5', // 9 AM weekdays
  },

  output_count: {
    id: 'output_count',
    name: 'Output Count',
    description: 'Track daily deliverable output',
    questions: [
      { id: uuid(), text: 'How many items did you complete today?', type: 'number' as const, required: true },
      { id: uuid(), text: 'Are you blocked on anything?', type: 'boolean' as const, required: true },
      { id: uuid(), text: 'If blocked, describe the issue:', type: 'text' as const, required: false },
    ],
    defaultCron: '0 17 * * 1-5', // 5 PM weekdays
  },

  weekly_forecast: {
    id: 'weekly_forecast',
    name: 'Weekly Forecast',
    description: 'End-of-week reflection and planning',
    questions: [
      { id: uuid(), text: 'Key accomplishments this week:', type: 'text' as const, required: true },
      { id: uuid(), text: 'Goals for next week:', type: 'text' as const, required: true },
      { id: uuid(), text: 'Expected deliverable count:', type: 'number' as const, required: false },
      { id: uuid(), text: 'Risks or concerns:', type: 'text' as const, required: false },
    ],
    defaultCron: '0 16 * * 5', // 4 PM Friday
  },
} as const;

export type TemplateId = keyof typeof CHECK_IN_TEMPLATES;

/**
 * Get template by ID
 */
export function getTemplate(templateId: string): typeof CHECK_IN_TEMPLATES[TemplateId] | null {
  if (templateId in CHECK_IN_TEMPLATES) {
    return CHECK_IN_TEMPLATES[templateId as TemplateId];
  }
  return null;
}

/**
 * List all available templates
 */
export function listTemplates(): Array<{
  id: string;
  name: string;
  description: string;
  defaultCron: string;
}> {
  return Object.values(CHECK_IN_TEMPLATES).map((t) => ({
    id: t.id,
    name: t.name,
    description: t.description,
    defaultCron: t.defaultCron,
  }));
}

/**
 * Generate fresh question IDs for a template
 * (Templates have static IDs, but each block should have unique question IDs)
 */
export function getTemplateQuestions(templateId: string): CheckInQuestion[] | null {
  const template = getTemplate(templateId);
  if (!template) return null;

  return template.questions.map((q) => ({
    ...q,
    id: uuid(), // Fresh UUID for each use
  }));
}
```

3. Create src/features/check-ins/check-ins.service.ts:
```typescript
import { and, eq } from 'drizzle-orm';
import { db, schema } from '../../shared/db';
import { logger } from '../../shared/lib/logger';
import { checkInQueue } from './check-ins.worker';
import type { CreateCheckInBlockInput, UpdateCheckInBlockInput, CheckInBlockResult } from './check-ins.types';

/**
 * Create a new check-in block
 */
export async function createCheckInBlock(
  projectId: string,
  createdById: string,
  input: CreateCheckInBlockInput
): Promise<CheckInBlockResult> {
  const [block] = await db
    .insert(schema.checkInBlocks)
    .values({
      projectId,
      createdById,
      name: input.name,
      description: input.description ?? null,
      cronPattern: input.cronPattern,
      timezone: input.timezone,
      questions: input.questions,
      templateId: input.templateId ?? null,
      targetType: input.targetType,
      targetSquadId: input.targetSquadId ?? null,
      targetRole: input.targetRole ?? null,
      enabled: input.enabled,
    })
    .returning();

  logger.info({ blockId: block.id, projectId }, 'Check-in block created');

  // Schedule if enabled
  if (block.enabled) {
    await scheduleCheckInBlock(block.id);
  }

  return block as CheckInBlockResult;
}

/**
 * Update a check-in block
 */
export async function updateCheckInBlock(
  blockId: string,
  projectId: string,
  input: UpdateCheckInBlockInput
): Promise<CheckInBlockResult | null> {
  const [block] = await db
    .update(schema.checkInBlocks)
    .set({
      ...input,
      updatedAt: new Date(),
    })
    .where(and(
      eq(schema.checkInBlocks.id, blockId),
      eq(schema.checkInBlocks.projectId, projectId)
    ))
    .returning();

  if (!block) return null;

  // Reschedule jobs
  await cancelCheckInBlockJobs(blockId);
  if (block.enabled) {
    await scheduleCheckInBlock(blockId);
  }

  logger.info({ blockId }, 'Check-in block updated');
  return block as CheckInBlockResult;
}

/**
 * Delete a check-in block
 */
export async function deleteCheckInBlock(
  blockId: string,
  projectId: string
): Promise<boolean> {
  // Cancel scheduled jobs first
  await cancelCheckInBlockJobs(blockId);

  const result = await db
    .delete(schema.checkInBlocks)
    .where(and(
      eq(schema.checkInBlocks.id, blockId),
      eq(schema.checkInBlocks.projectId, projectId)
    ))
    .returning({ id: schema.checkInBlocks.id });

  return result.length > 0;
}

/**
 * Get check-in block by ID
 */
export async function getCheckInBlock(
  blockId: string,
  projectId: string
): Promise<CheckInBlockResult | null> {
  const block = await db.query.checkInBlocks.findFirst({
    where: and(
      eq(schema.checkInBlocks.id, blockId),
      eq(schema.checkInBlocks.projectId, projectId)
    ),
  });

  return block as CheckInBlockResult | null;
}

/**
 * List check-in blocks for a project
 */
export async function listCheckInBlocks(
  projectId: string
): Promise<CheckInBlockResult[]> {
  const blocks = await db.query.checkInBlocks.findMany({
    where: eq(schema.checkInBlocks.projectId, projectId),
    orderBy: (table, { desc }) => [desc(table.createdAt)],
  });

  return blocks as CheckInBlockResult[];
}

/**
 * Get target users for a check-in block
 */
export async function getTargetUsers(
  block: CheckInBlockResult
): Promise<Array<{ userId: string; timezone?: string }>> {
  const projectId = block.projectId;

  // Base query: all project members
  let members = await db.query.projectMembers.findMany({
    where: eq(schema.projectMembers.projectId, projectId),
    columns: { userId: true, role: true },
  });

  // Filter by target type
  if (block.targetType === 'squad' && block.targetSquadId) {
    const squadMembers = await db.query.squadMembers.findMany({
      where: eq(schema.squadMembers.squadId, block.targetSquadId),
      columns: { userId: true },
    });
    const squadUserIds = new Set(squadMembers.map((m) => m.userId));
    members = members.filter((m) => squadUserIds.has(m.userId));
  } else if (block.targetType === 'role' && block.targetRole) {
    members = members.filter((m) => m.role === block.targetRole);
  }

  // Get user timezones from user_messaging
  const userIds = members.map((m) => m.userId);
  const messagingPrefs = await db.query.userMessaging.findMany({
    where: eq(schema.userMessaging.messagingEnabled, true),
  });

  const prefsMap = new Map(messagingPrefs.map((p) => [p.userId, p]));

  // Only include users with messaging enabled
  return userIds
    .filter((userId) => prefsMap.has(userId))
    .map((userId) => ({
      userId,
      // Note: timezone would come from user preferences if we add it
    }));
}

/**
 * Schedule check-in jobs for all target users
 */
export async function scheduleCheckInBlock(blockId: string): Promise<void> {
  const block = await db.query.checkInBlocks.findFirst({
    where: eq(schema.checkInBlocks.id, blockId),
  });

  if (!block || !block.enabled) {
    logger.info({ blockId }, 'Block not found or disabled, skipping scheduling');
    return;
  }

  const users = await getTargetUsers(block as CheckInBlockResult);
  logger.info({ blockId, userCount: users.length }, 'Scheduling check-in jobs');

  for (const user of users) {
    const jobId = `check-in-${blockId}-${user.userId}`;

    await checkInQueue.add(
      jobId,
      {
        type: 'send_check_in',
        checkInBlockId: blockId,
        userId: user.userId,
      },
      {
        repeat: {
          pattern: block.cronPattern,
          tz: block.timezone, // BullMQ timezone support
        },
        jobId,
      }
    );
  }
}

/**
 * Cancel all scheduled jobs for a check-in block
 */
export async function cancelCheckInBlockJobs(blockId: string): Promise<void> {
  // Get all repeatable jobs
  const repeatableJobs = await checkInQueue.getRepeatableJobs();

  for (const job of repeatableJobs) {
    if (job.id?.startsWith(`check-in-${blockId}-`)) {
      await checkInQueue.removeRepeatableByKey(job.key);
      logger.info({ jobKey: job.key }, 'Cancelled check-in job');
    }
  }
}

/**
 * Format check-in questions as a message
 */
export function formatCheckInPrompt(name: string, questions: schema.CheckInQuestion[]): string {
  const lines = [`Check-in: ${name}`, ''];

  questions.forEach((q, i) => {
    const requiredMark = q.required ? '*' : '';
    lines.push(`${i + 1}. ${q.text}${requiredMark}`);

    if (q.type === 'select' && q.options) {
      lines.push(`   Options: ${q.options.join(', ')}`);
    } else if (q.type === 'number') {
      lines.push(`   (Enter a number)`);
    } else if (q.type === 'boolean') {
      lines.push(`   (Yes/No)`);
    }
  });

  lines.push('', 'Reply with your answers to complete the check-in.');

  return lines.join('\n');
}

/**
 * Record that a check-in was sent
 */
export async function recordCheckInSent(
  checkInBlockId: string,
  userId: string
): Promise<string> {
  const [response] = await db
    .insert(schema.checkInResponses)
    .values({
      checkInBlockId,
      userId,
      status: 'pending',
      sentAt: new Date(),
    })
    .returning({ id: schema.checkInResponses.id });

  return response.id;
}
```
  </action>
  <verify>bun run typecheck passes</verify>
  <done>Check-in types, templates (daily_standup, output_count, weekly_forecast), and service implemented</done>
</task>

<task type="auto">
  <name>Task 3: Create check-in worker, routes, and integrate</name>
  <files>src/features/check-ins/check-ins.worker.ts, src/features/check-ins/check-ins.routes.ts, src/features/check-ins/index.ts, src/shared/lib/queue/client.ts, src/index.ts</files>
  <action>
1. Add check-in queue to src/shared/lib/queue/client.ts:
```typescript
// Add with other queue imports
export const checkInQueue = new Queue('check-ins', {
  connection: getQueueConnection(),
});

// Update closeQueueConnections to include:
await checkInQueue.close();
```

2. Create src/features/check-ins/check-ins.worker.ts:
```typescript
import { Queue, Worker } from 'bullmq';
import { eq } from 'drizzle-orm';
import { db, schema } from '../../shared/db';
import { logger } from '../../shared/lib/logger';
import { getQueueConnection, checkInQueue } from '../../shared/lib/queue/client';
import { registerWorker } from '../../shared/lib/queue/workers';
import { sendTelegramMessage } from '../telegram';
import { sendWhatsAppMessage } from '../whatsapp/whatsapp.client';
import { formatCheckInPrompt, recordCheckInSent } from './check-ins.service';
import type { CheckInJobData } from './check-ins.types';

/**
 * Deliver check-in message to user via their preferred channels
 */
async function deliverCheckInMessage(userId: string, message: string): Promise<boolean> {
  const userMessaging = await db.query.userMessaging.findFirst({
    where: eq(schema.userMessaging.userId, userId),
  });

  if (!userMessaging?.messagingEnabled) {
    logger.info({ userId }, 'Messaging disabled, skipping check-in delivery');
    return false;
  }

  let delivered = false;

  // Deliver via Telegram
  if (userMessaging.telegramChatId && userMessaging.telegramVerified) {
    try {
      await sendTelegramMessage(userMessaging.telegramChatId, message);
      logger.info({ userId, platform: 'telegram' }, 'Check-in delivered');
      delivered = true;
    } catch (err) {
      logger.error({ err, userId }, 'Failed to deliver check-in via Telegram');
    }
  }

  // Deliver via WhatsApp
  if (userMessaging.whatsappPhone && userMessaging.whatsappVerified) {
    try {
      await sendWhatsAppMessage(userMessaging.whatsappPhone, message);
      logger.info({ userId, platform: 'whatsapp' }, 'Check-in delivered');
      delivered = true;
    } catch (err) {
      logger.error({ err, userId }, 'Failed to deliver check-in via WhatsApp');
    }
  }

  return delivered;
}

/**
 * Check-in worker - sends scheduled check-in prompts
 */
export const checkInWorker = new Worker<CheckInJobData>(
  'check-ins',
  async (job) => {
    const { checkInBlockId, userId } = job.data;
    logger.info({ jobId: job.id, checkInBlockId, userId }, 'Processing check-in job');

    // Get check-in block configuration
    const block = await db.query.checkInBlocks.findFirst({
      where: eq(schema.checkInBlocks.id, checkInBlockId),
    });

    if (!block) {
      logger.warn({ checkInBlockId }, 'Check-in block not found, skipping');
      return;
    }

    if (!block.enabled) {
      logger.info({ checkInBlockId }, 'Check-in block disabled, skipping');
      return;
    }

    // Format check-in message
    const message = formatCheckInPrompt(block.name, block.questions);

    // Deliver to user
    const delivered = await deliverCheckInMessage(userId, message);

    if (delivered) {
      // Record that check-in was sent
      await recordCheckInSent(checkInBlockId, userId);
    }
  },
  {
    connection: getQueueConnection(),
    concurrency: 10,
  }
);

// Register for graceful shutdown
registerWorker(checkInWorker);

export { checkInQueue };
```

3. Create src/features/check-ins/check-ins.routes.ts:
```typescript
import { Hono } from 'hono';
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';
import { authMiddleware, type AuthContext } from '../auth/auth.middleware';
import { visibilityMiddleware, type VisibilityContext } from '../visibility/visibility.middleware';
import { ApiError } from '../../shared/types';
import {
  createCheckInBlock,
  updateCheckInBlock,
  deleteCheckInBlock,
  getCheckInBlock,
  listCheckInBlocks,
} from './check-ins.service';
import { createCheckInBlockSchema, updateCheckInBlockSchema } from './check-ins.types';
import { listTemplates, getTemplate, getTemplateQuestions } from './check-ins.templates';

type CheckInContext = AuthContext & VisibilityContext;
const app = new Hono<CheckInContext>();

app.use('*', authMiddleware);
app.use('*', visibilityMiddleware);

// List available templates
app.get('/templates', async (c) => {
  const templates = listTemplates();
  return c.json({ data: templates });
});

// Get template details with questions
app.get('/templates/:templateId', async (c) => {
  const templateId = c.req.param('templateId');
  const template = getTemplate(templateId);

  if (!template) {
    throw new ApiError(404, 'Template not found');
  }

  // Generate fresh question IDs
  const questions = getTemplateQuestions(templateId);

  return c.json({
    data: {
      id: template.id,
      name: template.name,
      description: template.description,
      defaultCron: template.defaultCron,
      questions,
    },
  });
});

// Project-scoped routes
const projectRoutes = new Hono<CheckInContext>();

// List check-in blocks for project
projectRoutes.get('/', async (c) => {
  const projectId = c.req.param('projectId');

  // Verify user has access to project
  const visibleProjectIds = c.get('visibleProjectIds');
  if (!visibleProjectIds.includes(projectId)) {
    throw new ApiError(403, 'Access denied to this project');
  }

  const blocks = await listCheckInBlocks(projectId);
  return c.json({ data: blocks });
});

// Create check-in block (admin/pm only)
projectRoutes.post(
  '/',
  zValidator('json', createCheckInBlockSchema),
  async (c) => {
    const projectId = c.req.param('projectId');
    const userId = c.get('userId');
    const input = c.req.valid('json');

    // Verify user has access to project
    const visibleProjectIds = c.get('visibleProjectIds');
    if (!visibleProjectIds.includes(projectId)) {
      throw new ApiError(403, 'Access denied to this project');
    }

    // TODO: Check if user is admin/pm for this project

    const block = await createCheckInBlock(projectId, userId, input);
    return c.json({ data: block }, 201);
  }
);

// Get check-in block
projectRoutes.get('/:blockId', async (c) => {
  const projectId = c.req.param('projectId');
  const blockId = c.req.param('blockId');

  const visibleProjectIds = c.get('visibleProjectIds');
  if (!visibleProjectIds.includes(projectId)) {
    throw new ApiError(403, 'Access denied to this project');
  }

  const block = await getCheckInBlock(blockId, projectId);
  if (!block) {
    throw new ApiError(404, 'Check-in block not found');
  }

  return c.json({ data: block });
});

// Update check-in block
projectRoutes.patch(
  '/:blockId',
  zValidator('json', updateCheckInBlockSchema),
  async (c) => {
    const projectId = c.req.param('projectId');
    const blockId = c.req.param('blockId');
    const input = c.req.valid('json');

    const visibleProjectIds = c.get('visibleProjectIds');
    if (!visibleProjectIds.includes(projectId)) {
      throw new ApiError(403, 'Access denied to this project');
    }

    const block = await updateCheckInBlock(blockId, projectId, input);
    if (!block) {
      throw new ApiError(404, 'Check-in block not found');
    }

    return c.json({ data: block });
  }
);

// Delete check-in block
projectRoutes.delete('/:blockId', async (c) => {
  const projectId = c.req.param('projectId');
  const blockId = c.req.param('blockId');

  const visibleProjectIds = c.get('visibleProjectIds');
  if (!visibleProjectIds.includes(projectId)) {
    throw new ApiError(403, 'Access denied to this project');
  }

  const deleted = await deleteCheckInBlock(blockId, projectId);
  if (!deleted) {
    throw new ApiError(404, 'Check-in block not found');
  }

  return c.json({ data: { deleted: true } });
});

// Mount project routes
app.route('/projects/:projectId/check-in-blocks', projectRoutes);

export default app;
```

4. Create src/features/check-ins/index.ts:
```typescript
export { default as checkInsRoutes } from './check-ins.routes';
export { checkInWorker, checkInQueue } from './check-ins.worker';
export {
  createCheckInBlock,
  updateCheckInBlock,
  deleteCheckInBlock,
  getCheckInBlock,
  listCheckInBlocks,
  scheduleCheckInBlock,
  cancelCheckInBlockJobs,
  formatCheckInPrompt,
} from './check-ins.service';
export { CHECK_IN_TEMPLATES, getTemplate, listTemplates, getTemplateQuestions } from './check-ins.templates';
export type { CheckInBlockResult, CheckInJobData, CreateCheckInBlockInput, UpdateCheckInBlockInput } from './check-ins.types';
```

5. Register routes and import worker in src/index.ts:
```typescript
// Add imports
import { checkInsRoutes } from './features/check-ins';
import './features/check-ins/check-ins.worker';

// Add route
app.route('/api/v1/check-ins', checkInsRoutes);
```
  </action>
  <verify>bun run typecheck passes, bun run lint passes</verify>
  <done>Check-in worker delivers at scheduled times, admin API routes registered</done>
</task>

</tasks>

<verification>
- [ ] Migration creates check_in_blocks and check_in_responses tables
- [ ] GET /api/v1/check-ins/templates returns available templates
- [ ] GET /api/v1/check-ins/templates/:id returns template with fresh question IDs
- [ ] POST /api/v1/check-ins/projects/:projectId/check-in-blocks creates block
- [ ] GET /api/v1/check-ins/projects/:projectId/check-in-blocks lists blocks
- [ ] PATCH /api/v1/check-ins/projects/:projectId/check-in-blocks/:id updates block
- [ ] DELETE /api/v1/check-ins/projects/:projectId/check-in-blocks/:id deletes block
- [ ] BullMQ repeatable jobs scheduled with timezone support
- [ ] Worker delivers check-in prompts via Telegram/WhatsApp
- [ ] bun run typecheck and bun run lint pass
</verification>

<success_criteria>
- Admin can create check-in block with custom questions and cron schedule
- Admin can select from 3 preset templates (daily_standup, output_count, weekly_forecast)
- Check-in blocks can target all users, specific squad, or specific role
- Scheduled check-ins delivered via Telegram and WhatsApp
- Questions support text, number, select, and boolean types
</success_criteria>

<output>
After completion, create `.planning/phases/06-check-ins-escalations/06-01-SUMMARY.md`
</output>
