---
phase: 04-tasks-deliverables
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - src/shared/db/schema/dependencies.ts
  - src/shared/db/schema/custom-fields.ts
  - src/shared/db/schema/index.ts
  - src/features/dependencies/dependencies.types.ts
  - src/features/dependencies/dependencies.service.ts
  - src/features/dependencies/dependencies.routes.ts
  - src/features/dependencies/index.ts
  - src/features/custom-fields/custom-fields.types.ts
  - src/features/custom-fields/custom-fields.service.ts
  - src/features/custom-fields/custom-fields.routes.ts
  - src/features/custom-fields/index.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "User can define task dependencies (X blocks Y)"
    - "Cross-type dependencies work (task blocks deliverable, deliverable blocks task)"
    - "Circular dependencies are detected and rejected with 400 error"
    - "Admin can create custom field definitions at project level"
    - "Custom fields can apply to tasks, deliverables, or both"
    - "Custom field values are validated against field definitions"
  artifacts:
    - path: "src/shared/db/schema/dependencies.ts"
      provides: "Polymorphic dependencies table"
      contains: "blockerType"
    - path: "src/features/dependencies/dependencies.service.ts"
      provides: "Dependency management with DFS cycle detection"
      exports: ["createDependency", "wouldCreateCycle"]
    - path: "src/shared/db/schema/custom-fields.ts"
      provides: "Custom field definitions table"
      contains: "appliesToTasks"
    - path: "src/features/custom-fields/custom-fields.service.ts"
      provides: "Custom field CRUD and validation"
      exports: ["validateCustomFieldValues", "buildFieldValidator"]
  key_links:
    - from: "src/features/dependencies/dependencies.service.ts"
      to: "src/shared/db/schema/dependencies.ts"
      via: "Drizzle queries for DFS traversal"
      pattern: "schema\\.dependencies"
    - from: "src/features/custom-fields/custom-fields.service.ts"
      to: "zod"
      via: "Dynamic schema building"
      pattern: "z\\.(string|number|enum|array)"
---

<objective>
Implement cross-type task/deliverable dependencies with cycle detection, and project-level custom field definitions with runtime validation.

Purpose: Enable users to define blocking relationships between work items and customize fields for their workflow needs.
Output: Dependencies schema with DFS cycle detection, custom fields schema with Zod-based validation, REST APIs for both.
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-tasks-deliverables/04-CONTEXT.md
@.planning/phases/04-tasks-deliverables/04-RESEARCH.md

Reference prior plan outputs:
@.planning/phases/04-tasks-deliverables/04-01-SUMMARY.md
@.planning/phases/04-tasks-deliverables/04-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dependencies schema and service with cycle detection</name>
  <files>
    src/shared/db/schema/dependencies.ts
    src/shared/db/schema/index.ts
    src/features/dependencies/dependencies.types.ts
    src/features/dependencies/dependencies.service.ts
    src/features/dependencies/index.ts
  </files>
  <action>
Create polymorphic dependencies with DFS cycle detection following 04-RESEARCH.md:

1. Create `src/shared/db/schema/dependencies.ts`:
   - Create dependencies table:
     - id: uuid primary key defaultRandom()
     - blockerType: varchar(20) not null ('task' | 'deliverable')
     - blockerId: uuid not null
     - blockedType: varchar(20) not null ('task' | 'deliverable')
     - blockedId: uuid not null
     - createdById: uuid not null (referencing users.id)
     - createdAt: timestamp with timezone defaultNow()
   - Add unique constraint on (blockerType, blockerId, blockedType, blockedId) to prevent duplicates

2. Export from `src/shared/db/schema/index.ts`

3. Create `src/features/dependencies/dependencies.types.ts`:
   - DependencyNode: { type: 'task' | 'deliverable', id: string }
   - CreateDependencyInput: { blocker: DependencyNode, blocked: DependencyNode }
   - DependencyResult: inferred select type
   - DependencyWithDetails: DependencyResult with blocker/blocked item details

4. Create `src/features/dependencies/dependencies.service.ts`:
   - wouldCreateCycle(from: DependencyNode, to: DependencyNode): boolean
     - If from equals to (same type and id), return true immediately
     - DFS from "to" node to see if we can reach "from"
     - Use visited Set with key format "{type}:{id}"
     - For each node, query dependencies where node is the blocker
     - If any blocked node leads back to "from", return true
     - Return false if DFS completes without finding cycle

   - createDependency(input, createdById):
     - Call wouldCreateCycle first
     - If would create cycle, throw ApiError 400 'dependencies/cycle-detected'
     - Insert dependency and return

   - deleteDependency(dependencyId): Delete single dependency

   - getDependenciesFor(node: DependencyNode, direction: 'blocks' | 'blocked_by'):
     - 'blocks': items this node blocks (node is blocker)
     - 'blocked_by': items blocking this node (node is blocked)
     - Return with item details (fetch task or deliverable based on type)

   - isBlocked(node: DependencyNode): boolean
     - Check if any incomplete items block this node
     - "Incomplete" means: task status != 'done' OR deliverable has non-final status

5. Create barrel export `src/features/dependencies/index.ts`
  </action>
  <verify>
Run `bun run typecheck` - no TypeScript errors.
Run `bun run db:generate` - migration generated.
  </verify>
  <done>
Dependencies schema and service created with DFS cycle detection algorithm that works across task and deliverable types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create custom fields schema and validation service</name>
  <files>
    src/shared/db/schema/custom-fields.ts
    src/features/custom-fields/custom-fields.types.ts
    src/features/custom-fields/custom-fields.service.ts
    src/features/custom-fields/index.ts
  </files>
  <action>
Create custom field definitions and Zod-based validation following 04-RESEARCH.md:

1. Create `src/shared/db/schema/custom-fields.ts`:
   - Define FieldConfig interface: { options?: string[], min?: number, max?: number, relationTo?: 'task' | 'deliverable', allowMultiple?: boolean }
   - Create customFields table:
     - id: uuid primary key defaultRandom()
     - projectId: uuid referencing projects.id with cascade delete
     - name: varchar(255) not null
     - type: varchar(50) not null (text, number, date, select, multi_select, url, file, relation)
     - config: jsonb with $type<FieldConfig> default {}
     - required: boolean not null default false
     - appliesToTasks: boolean not null default true
     - appliesToDeliverables: boolean not null default true
     - createdAt/updatedAt: timestamps

2. Export from schema index.ts

3. Create `src/features/custom-fields/custom-fields.types.ts`:
   - CreateCustomFieldInput: { projectId, name, type, config?, required?, appliesToTasks?, appliesToDeliverables? }
   - UpdateCustomFieldInput: Partial of editable fields (NOT type - prevent type changes)
   - CustomFieldResult: inferred select type

4. Create `src/features/custom-fields/custom-fields.service.ts`:
   - buildFieldValidator(field): z.ZodTypeAny
     - Switch on field.type:
       - 'text' -> z.string()
       - 'number' -> z.number() with min/max from config
       - 'date' -> z.string().datetime()
       - 'select' -> z.enum(config.options)
       - 'multi_select' -> z.array(z.enum(config.options))
       - 'url' -> z.string().url()
       - 'file' -> z.object({ attachmentId: z.string().uuid(), filename: z.string(), url: z.string().url() })
       - 'relation' -> z.string().uuid()
       - default -> z.unknown()

   - validateCustomFieldValues(projectId, values, target: 'task' | 'deliverable'):
     - Fetch all custom fields for project that apply to target
     - For each field:
       - Check required fields are present
       - Validate value type using buildFieldValidator
     - Return { valid: boolean, errors: string[] }

   - createCustomField(input): Insert and return
   - updateCustomField(fieldId, input):
     - Prevent type changes (throw error if type in input)
     - Update other fields
   - deleteCustomField(fieldId): Delete field
   - getCustomField(fieldId): Fetch single
   - listCustomFields(projectId, target?: 'task' | 'deliverable'): Filter by appliesToTasks/appliesToDeliverables

5. Create barrel export
  </action>
  <verify>
Run `bun run typecheck` - no TypeScript errors.
Run `bun run db:generate` - migration generated.
  </verify>
  <done>
Custom fields schema and service created with dynamic Zod validation for all field types (text, number, date, select, multi_select, url, file, relation).
  </done>
</task>

<task type="auto">
  <name>Task 3: Create routes for dependencies and custom fields</name>
  <files>
    src/features/dependencies/dependencies.routes.ts
    src/features/custom-fields/custom-fields.routes.ts
    src/index.ts
  </files>
  <action>
Create REST endpoints for dependencies and custom fields:

1. Create `src/features/dependencies/dependencies.routes.ts`:
   - Import Hono, zod, authMiddleware, visibilityMiddleware
   - Apply middleware

   Endpoints:
   - POST / - Create dependency
     - Body: { blocker: { type, id }, blocked: { type, id } }
     - Call dependenciesService.createDependency
     - Return 201 or 400 if cycle detected

   - DELETE /:dependencyId - Delete dependency
     - Return 204

   - GET /for/:type/:itemId - Get dependencies for an item
     - Query: direction ('blocks' | 'blocked_by')
     - Call dependenciesService.getDependenciesFor
     - Return array of dependencies with item details

   - GET /blocked/:type/:itemId - Check if item is blocked
     - Call dependenciesService.isBlocked
     - Return { blocked: boolean, blockedBy: DependencyNode[] }

2. Create `src/features/custom-fields/custom-fields.routes.ts`:
   - Apply middleware

   Endpoints:
   - POST / - Create custom field (admin only)
     - Body: CreateCustomFieldInput
     - Return 201

   - GET / - List custom fields
     - Query: projectId (required), target? ('task' | 'deliverable')
     - Return array

   - GET /:fieldId - Get single field
     - Return field

   - PATCH /:fieldId - Update field (admin only)
     - Body: UpdateCustomFieldInput (type not allowed)
     - Return updated field or 400 if trying to change type

   - DELETE /:fieldId - Delete field (admin only)
     - Return 204

   - POST /validate - Validate field values
     - Body: { projectId, values: Record<string, unknown>, target: 'task' | 'deliverable' }
     - Call validateCustomFieldValues
     - Return { valid: boolean, errors: string[] }

3. Wire routes in `src/index.ts`:
   - Import dependenciesRoutes from './features/dependencies'
   - Import customFieldsRoutes from './features/custom-fields'
   - Mount at '/api/v1/dependencies' and '/api/v1/custom-fields'
  </action>
  <verify>
Run `bun run typecheck` - no TypeScript errors.
Run `bun run lint` - no linting errors.
Run `bun run db:migrate` - migrations applied.
Test:
- Create dependency: POST /api/v1/dependencies returns 201
- Create circular: POST returns 400 with cycle-detected error
- Create custom field: POST /api/v1/custom-fields returns 201
- Validate values: POST /api/v1/custom-fields/validate returns { valid, errors }
  </verify>
  <done>
Dependencies and custom fields REST APIs complete. Dependencies support cross-type blocking with cycle detection. Custom fields support all 8 field types with validation.
  </done>
</task>

</tasks>

<verification>
1. Creating A blocks B then B blocks A returns 400 cycle error
2. Cross-type dependency works (task blocks deliverable)
3. isBlocked returns true when blocking item is incomplete
4. Custom field with type 'select' validates against options
5. Required custom field validation works
6. Changing field type is prevented (returns 400)
</verification>

<success_criteria>
- Dependencies table stores cross-type blocking relationships
- DFS cycle detection prevents circular dependencies
- Custom fields table stores field definitions with config
- Zod-based validation works for all field types
- TypeScript compiles without errors
- Linter passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-tasks-deliverables/04-03-SUMMARY.md`
</output>
